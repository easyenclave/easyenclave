# CI for EasyEnclave
#
# This workflow runs linting, tests, and deploys to the TDX runner.

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  cleanup-tdx-runner:
    name: Cleanup - Local TDX VMs
    runs-on: [self-hosted, tdx]
    concurrency:
      # Do not overlap with other workflows that mutate the shared control plane / TDX runner.
      group: easyenclave-shared-control-plane
      cancel-in-progress: false
    # Avoid running destructive cleanup on PRs from forks.
    if: github.event_name == 'push'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Local VM inventory (before)
        shell: bash
        run: |
          set -euo pipefail
          echo "=== virsh list --all ==="
          virsh list --all || true
          echo ""
          echo "=== tdx_cli vm list ==="
          python3 infra/tdx_cli.py vm list || true
          echo ""
          echo "=== /var/tmp/tdvirsh disk usage ==="
          sudo du -sh /var/tmp/tdvirsh 2>/dev/null || du -sh /var/tmp/tdvirsh 2>/dev/null || true

      - name: Delete all existing EasyEnclave TDX VMs
        shell: bash
        run: |
          set -euo pipefail
          python3 infra/tdx_cli.py vm delete all || true

          # Extra safety: measurement VMs are always safe to delete and sometimes leak on timeouts.
          if command -v virsh >/dev/null 2>&1; then
            for d in $(virsh list --all --name | grep '^tdvirsh-trust_domain_verity-' || true); do
              [ -n "$d" ] || continue
              virsh destroy "$d" >/dev/null 2>&1 || true
              virsh undefine "$d" --nvram >/dev/null 2>&1 || virsh undefine "$d" >/dev/null 2>&1 || true
            done
          fi

      - name: Local VM inventory (after)
        shell: bash
        run: |
          set -euo pipefail
          echo "=== virsh list --all ==="
          virsh list --all || true
          echo ""
          echo "=== tdx_cli vm list ==="
          python3 infra/tdx_cli.py vm list || true

  measure-trusted-values:
    name: Measure Trusted Values (tiny)
    runs-on: [self-hosted, tdx]
    concurrency:
      # Serialized with cleanup/bootstrap and other CP-mutating workflows.
      group: easyenclave-shared-control-plane
      cancel-in-progress: false
    if: github.event_name == 'push'
    needs: [cleanup-tdx-runner]
    permissions:
      contents: read
    env:
      # Infra + trust.
      INTEL_API_KEY: ${{ secrets.INTEL_API_KEY }}
      ITA_API_KEY: ${{ secrets.INTEL_API_KEY }}
      # Optional: CP-native GCP provisioning credentials (used to fulfill gcp:* launch orders).
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GCP_SERVICE_ACCOUNT_KEY: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
      # Optional: allow CP-native provisioning to inject ITA keys into provisioned agent VMs.
      EE_AGENT_ITA_API_KEY: ${{ secrets.INTEL_API_KEY }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          set -euo pipefail
          for v in INTEL_API_KEY; do
            if [ -z "${!v:-}" ]; then
              echo "::error::Missing required secret/env: $v"
              exit 1
            fi
          done

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Build and measure trusted values (tiny)
        id: measure
        env:
          MEASURE_SIZES: tiny
        run: ./scripts/ci-build-measure.sh

      - name: Export trusted values to job outputs
        id: out
        shell: bash
        run: |
          set -euo pipefail
          {
            # IMPORTANT: These outputs are JSON strings that include double quotes.
            # If we wrap the echo argument in double quotes, bash will treat those
            # embedded quotes as syntax and the output will be mangled into
            # non-JSON like {tiny:...}. Use single quotes so JSON is preserved.
            echo 'mrtds=${{ steps.measure.outputs.mrtds }}'
            echo 'mrtds_by_size=${{ steps.measure.outputs.mrtds_by_size }}'
            echo 'rtmrs=${{ steps.measure.outputs.rtmrs }}'
            echo 'rtmrs_by_size=${{ steps.measure.outputs.rtmrs_by_size }}'
          } >> "$GITHUB_OUTPUT"

    outputs:
      mrtds: ${{ steps.out.outputs.mrtds }}
      mrtds_by_size: ${{ steps.out.outputs.mrtds_by_size }}
      rtmrs: ${{ steps.out.outputs.rtmrs }}
      rtmrs_by_size: ${{ steps.out.outputs.rtmrs_by_size }}

  bootstrap-control-plane:
    name: Bootstrap Control Plane
    runs-on: [self-hosted, tdx]
    concurrency:
      # Serialized with cleanup/measure and other CP-mutating workflows.
      group: easyenclave-shared-control-plane
      cancel-in-progress: false
    if: github.event_name == 'push'
    # Everything can run in parallel except launching the CP VM; this must wait for:
    # 1) docker images for this SHA to be pushed, and
    # 2) measured trusted values from the TDX runner.
    needs: [docker, measure-trusted-values]
    permissions:
      contents: read
    env:
      # Coordination metadata (exposed by /health).
      EASYENCLAVE_BOOT_ID: ci-${{ github.run_id }}-${{ github.run_attempt }}
      EASYENCLAVE_GIT_SHA: ${{ github.sha }}

      # Infra + trust.
      INTEL_API_KEY: ${{ secrets.INTEL_API_KEY }}
      ITA_API_KEY: ${{ secrets.INTEL_API_KEY }}

      # Cloudflare (public endpoint for https://app.easyenclave.com).
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}

      # GitHub OAuth (admin login + deployer identity).
      GITHUB_OAUTH_CLIENT_ID: ${{ secrets.EE_GITHUB_OAUTH_CLIENT_ID }}
      GITHUB_OAUTH_CLIENT_SECRET: ${{ secrets.EE_GITHUB_OAUTH_CLIENT_SECRET }}
      GITHUB_OAUTH_REDIRECT_URI: ${{ secrets.EE_GITHUB_OAUTH_REDIRECT_URI }}
      ADMIN_GITHUB_LOGINS: ${{ secrets.ADMIN_GITHUB_LOGINS }}

      # Stripe (optional billing).
      STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
      STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}

      # Admin password for bootstrap (used to attest the initial measurer).
      ADMIN_PASSWORD: ${{ secrets.CP_ADMIN_PASSWORD }}

      # Bootstrap sizes/capacity.
      CP_BOOTSTRAP_SIZES: tiny
      # Total tiny capacity on bootstrap = 3 (1 bootstrap measurer + 2 additional).
      NUM_TINY_AGENTS: "2"
      NUM_STANDARD_AGENTS: "0"
      NUM_LLM_AGENTS: "0"

      # Boot the exact revision built in this CI run.
      CONTROL_PLANE_IMAGE: ghcr.io/${{ github.repository }}/control-plane:${{ github.sha }}
      MEASURER_IMAGE: ghcr.io/${{ github.repository }}/measuring-enclave:${{ github.sha }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Preserve infra/image/output produced by measure-trusted-values so tdx_cli can
          # launch VMs without rebuilding (it defaults to infra/image/output).
          clean: false

      - name: Validate required secrets
        run: |
          set -euo pipefail
          for v in INTEL_API_KEY CLOUDFLARE_API_TOKEN CLOUDFLARE_ACCOUNT_ID CLOUDFLARE_ZONE_ID ADMIN_PASSWORD; do
            if [ -z "${!v:-}" ]; then
              echo "::error::Missing required secret/env: $v"
              exit 1
            fi
          done

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Ensure verity artifacts exist
        shell: bash
        run: |
          set -euo pipefail
          need_build=0
          for f in easyenclave.vmlinuz easyenclave.initrd easyenclave.root.raw easyenclave.cmdline; do
            if [ ! -f "infra/image/output/$f" ]; then
              need_build=1
            fi
          done

          if [ "$need_build" -eq 1 ]; then
            echo "Verity artifacts missing; building infra/image/output..."
            # mkosi needs unprivileged user namespaces
            sudo sysctl -w kernel.apparmor_restrict_unprivileged_userns=0
            (cd infra/image && nix develop --command bash -lc 'make build')
          fi

      - name: Derive ADMIN_PASSWORD_HASH (for control plane container)
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import os
          import bcrypt
          pw = os.environ.get("ADMIN_PASSWORD", "").encode()
          if not pw:
            raise SystemExit("ADMIN_PASSWORD missing")
          hashed = bcrypt.hashpw(pw, bcrypt.gensalt()).decode()
          with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as f:
            f.write("ADMIN_PASSWORD_HASH=" + hashed + "\n")
          PY

      - name: Cleanup leaked measurement VMs (best effort)
        run: |
          set -euo pipefail
          if command -v virsh >/dev/null 2>&1; then
            for d in $(virsh list --all --name | grep '^tdvirsh-trust_domain_verity-' || true); do
              [ -n "$d" ] || continue
              virsh destroy "$d" >/dev/null 2>&1 || true
              virsh undefine "$d" --nvram >/dev/null 2>&1 || virsh undefine "$d" >/dev/null 2>&1 || true
            done
          fi

      - name: Deploy control plane + bootstrap agents/apps
        env:
          TRUSTED_AGENT_MRTDS: ${{ needs.measure-trusted-values.outputs.mrtds }}
          # Quote JSON-like strings to prevent YAML from parsing them as flow mappings.
          TRUSTED_AGENT_MRTDS_BY_SIZE: '${{ needs.measure-trusted-values.outputs.mrtds_by_size }}'
          TRUSTED_AGENT_RTMRS: '${{ needs.measure-trusted-values.outputs.rtmrs }}'
          TRUSTED_AGENT_RTMRS_BY_SIZE: '${{ needs.measure-trusted-values.outputs.rtmrs_by_size }}'
        run: ./scripts/ci-deploy.sh

  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: requirements.txt

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-asyncio pytest-httpx httpx

      - name: Install SDK
        run: |
          pip install -e sdk/

      - name: Install linting tools
        run: |
          pip install ruff
          curl -sL https://github.com/rhysd/actionlint/releases/download/v1.7.10/actionlint_1.7.10_linux_amd64.tar.gz | tar xz
          sudo mv actionlint /usr/local/bin/

      - name: Run linting
        run: ./scripts/lint.sh

      - name: Run tests
        run: |
          pytest tests/test_agent_registration_e2e.py -v
          pytest tests/ -v --ignore=tests/test_agent_registration_e2e.py

  docker:
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install cosign
        if: github.event_name == 'push'
        uses: sigstore/cosign-installer@v3

      - name: Build Docker image
        run: |
          docker build -t easyenclave:test .

      - name: Test Docker image
        run: |
          # Start the container
          docker run -d --name easyenclave-test -p 8080:8080 easyenclave:test

          # Wait for startup
          sleep 5

          # Test health endpoint
          curl -f http://localhost:8080/health || exit 1

          # Test API endpoint
          curl -f http://localhost:8080/api/v1/services || exit 1

          # Cleanup
          docker stop easyenclave-test
          docker rm easyenclave-test

      - name: Build and push measuring enclave image
        id: measurer
        if: github.event_name == 'push'
        run: |
          retry_push() {
            local image_ref="$1"
            local attempts=5
            local delay=3
            for attempt in $(seq 1 "$attempts"); do
              if docker push "$image_ref"; then
                return 0
              fi
              if [ "$attempt" -lt "$attempts" ]; then
                echo "Push failed for $image_ref (attempt $attempt/$attempts), retrying in ${delay}s..."
                sleep "$delay"
              fi
            done
            echo "::error::Failed to push $image_ref after $attempts attempts"
            return 1
          }

          echo "${{ github.token }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin
          IMAGE="ghcr.io/${{ github.repository }}/measuring-enclave:${{ github.sha }}"
          LATEST="ghcr.io/${{ github.repository }}/measuring-enclave:latest"
          docker build -t "$IMAGE" -t "$LATEST" apps/measuring-enclave/
          retry_push "$IMAGE"
          retry_push "$LATEST"
          DIGEST_REF=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE")
          cosign sign --yes "$DIGEST_REF"
          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"
          echo "digest=$DIGEST_REF" >> "$GITHUB_OUTPUT"
          echo "Pushed $IMAGE"

          # Ensure the package is publicly pullable (agents have no ghcr.io credentials)
          PACKAGE_NAME="${{ github.event.repository.name }}%2Fmeasuring-enclave"
          gh api --method PATCH "/orgs/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME" \
            -f visibility=public || echo "::warning::Could not set package visibility to public"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Build and push control plane image
        id: control_plane
        if: github.event_name == 'push'
        run: |
          retry_push() {
            local image_ref="$1"
            local attempts=5
            local delay=3
            for attempt in $(seq 1 "$attempts"); do
              if docker push "$image_ref"; then
                return 0
              fi
              if [ "$attempt" -lt "$attempts" ]; then
                echo "Push failed for $image_ref (attempt $attempt/$attempts), retrying in ${delay}s..."
                sleep "$delay"
              fi
            done
            echo "::error::Failed to push $image_ref after $attempts attempts"
            return 1
          }

          echo "${{ github.token }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin
          IMAGE="ghcr.io/${{ github.repository }}/control-plane:${{ github.sha }}"
          LATEST="ghcr.io/${{ github.repository }}/control-plane:latest"
          docker build -t "$IMAGE" -t "$LATEST" .
          retry_push "$IMAGE"
          retry_push "$LATEST"
          DIGEST_REF=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE")
          cosign sign --yes "$DIGEST_REF"
          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"
          echo "digest=$DIGEST_REF" >> "$GITHUB_OUTPUT"

          # Make package public (control plane VM needs access without GHCR credentials)
          PACKAGE_NAME="${{ github.event.repository.name }}%2Fcontrol-plane"
          gh api --method PATCH "/orgs/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME" \
            -f visibility=public || echo "::warning::Could not set package visibility to public"
        env:
          GH_TOKEN: ${{ github.token }}
