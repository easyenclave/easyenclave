# CI for EasyEnclave
#
# This workflow runs linting, tests, and deploys to the TDX runner.

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: requirements.txt

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-asyncio pytest-httpx httpx

      - name: Install SDK
        run: |
          pip install -e sdk/

      - name: Install linting tools
        run: |
          pip install ruff
          curl -sL https://github.com/rhysd/actionlint/releases/download/v1.7.10/actionlint_1.7.10_linux_amd64.tar.gz | tar xz
          sudo mv actionlint /usr/local/bin/

      - name: Run linting
        run: ./scripts/lint.sh

      - name: Run tests
        run: |
          pytest tests/ -v

  docker:
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install cosign
        if: github.event_name == 'push'
        uses: sigstore/cosign-installer@v3

      - name: Build Docker image
        run: |
          docker build -t easyenclave:test .

      - name: Test Docker image
        run: |
          # Start the container
          docker run -d --name easyenclave-test -p 8080:8080 easyenclave:test

          # Wait for startup
          sleep 5

          # Test health endpoint
          curl -f http://localhost:8080/health || exit 1

          # Test API endpoint
          curl -f http://localhost:8080/api/v1/services || exit 1

          # Cleanup
          docker stop easyenclave-test
          docker rm easyenclave-test

      - name: Build and push measuring enclave image
        id: measurer
        if: github.event_name == 'push'
        run: |
          retry_push() {
            local image_ref="$1"
            local attempts=5
            local delay=3
            for attempt in $(seq 1 "$attempts"); do
              if docker push "$image_ref"; then
                return 0
              fi
              if [ "$attempt" -lt "$attempts" ]; then
                echo "Push failed for $image_ref (attempt $attempt/$attempts), retrying in ${delay}s..."
                sleep "$delay"
              fi
            done
            echo "::error::Failed to push $image_ref after $attempts attempts"
            return 1
          }

          echo "${{ github.token }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin
          IMAGE="ghcr.io/${{ github.repository }}/measuring-enclave:${{ github.sha }}"
          docker build -t "$IMAGE" apps/measuring-enclave/
          retry_push "$IMAGE"
          DIGEST_REF=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE")
          cosign sign --yes "$DIGEST_REF"
          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"
          echo "digest=$DIGEST_REF" >> "$GITHUB_OUTPUT"
          echo "Pushed $IMAGE"

          # Ensure the package is publicly pullable (agents have no ghcr.io credentials)
          PACKAGE_NAME="${{ github.event.repository.name }}%2Fmeasuring-enclave"
          gh api --method PATCH "/orgs/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME" \
            -f visibility=public || echo "::warning::Could not set package visibility to public"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Build and push control plane image
        id: control_plane
        if: github.event_name == 'push'
        run: |
          retry_push() {
            local image_ref="$1"
            local attempts=5
            local delay=3
            for attempt in $(seq 1 "$attempts"); do
              if docker push "$image_ref"; then
                return 0
              fi
              if [ "$attempt" -lt "$attempts" ]; then
                echo "Push failed for $image_ref (attempt $attempt/$attempts), retrying in ${delay}s..."
                sleep "$delay"
              fi
            done
            echo "::error::Failed to push $image_ref after $attempts attempts"
            return 1
          }

          echo "${{ github.token }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin
          IMAGE="ghcr.io/${{ github.repository }}/control-plane:${{ github.sha }}"
          LATEST="ghcr.io/${{ github.repository }}/control-plane:latest"
          docker build -t "$IMAGE" -t "$LATEST" .
          retry_push "$IMAGE"
          retry_push "$LATEST"
          DIGEST_REF=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE")
          cosign sign --yes "$DIGEST_REF"
          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"
          echo "digest=$DIGEST_REF" >> "$GITHUB_OUTPUT"

          # Make package public (control plane VM needs access without GHCR credentials)
          PACKAGE_NAME="${{ github.event.repository.name }}%2Fcontrol-plane"
          gh api --method PATCH "/orgs/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME" \
            -f visibility=public || echo "::warning::Could not set package visibility to public"
        env:
          GH_TOKEN: ${{ github.token }}

  build-and-deploy:
    runs-on: [self-hosted, tdx]
    if: github.event_name == 'push'

    permissions:
      actions: read
      contents: read

    env:
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      INTEL_API_KEY: ${{ secrets.INTEL_API_KEY }}
      ITA_API_KEY: ${{ secrets.INTEL_API_KEY }}
      STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
      STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
      # Cloud credentials (optional). Note: GitHub OIDC does not transfer into the TDX VM;
      # if the control plane itself needs to call cloud APIs, provide key-based creds.
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GCP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
      GCP_SERVICE_ACCOUNT: ${{ secrets.GCP_SERVICE_ACCOUNT }}
      GCP_SERVICE_ACCOUNT_KEY: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}

    steps:
      - name: Fix workspace permissions
        run: |
          if [ -d "infra/output" ]; then
            sudo chown -R "$(id -u):$(id -g)" infra/output/ || true
          fi
          if [ -d "infra/image/output" ]; then
            sudo chown -R "$(id -u):$(id -g)" infra/image/output/ || true
          fi

      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      # ---- Build (runs in parallel with test + docker) ----

      - name: Build and measure trusted values
        id: measure
        env:
          MEASURE_SIZES: tiny
        run: ./scripts/ci-build-measure.sh

      # ---- Wait for test + docker jobs before deploying ----

      - name: Wait for dependency jobs
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Waiting for test and docker jobs to complete..."
          while true; do
            JOBS=$(gh api "repos/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID/jobs" --jq '.jobs')
            TEST=$(echo "$JOBS" | jq -r '.[] | select(.name == "test") | .conclusion // "pending"')
            DOCKER=$(echo "$JOBS" | jq -r '.[] | select(.name == "docker") | .conclusion // "pending"')

            if [ "$TEST" = "failure" ] || [ "$DOCKER" = "failure" ]; then
              echo "::error::Dependency job failed (test=$TEST, docker=$DOCKER)"
              exit 1
            fi

            if [ "$TEST" = "success" ] && [ "$DOCKER" = "success" ]; then
              echo "All dependency jobs completed successfully"
              break
            fi

            echo "  test=$TEST docker=$DOCKER â€” waiting 15s..."
            sleep 15
          done

      - name: Resolve image digests (avoid GHCR tag flakiness)
        run: |
          set -euo pipefail

          resolve_digest_ref() {
            local image_tag="$1"
            local attempts=30
            local delay=5

            for attempt in $(seq 1 "$attempts"); do
              # Resolve tag -> digest using OCI Distribution API (no docker required on runner).
              #
              # GHCR typically requires a Bearer token even for public images, so we implement
              # the standard WWW-Authenticate challenge flow and then read Docker-Content-Digest.
              local registry name tag accept url headers www realm service scope token digest
              registry="ghcr.io"
              name="${image_tag#ghcr.io/}"
              tag="${name##*:}"
              name="${name%:*}"
              accept="application/vnd.docker.distribution.manifest.v2+json,application/vnd.oci.image.manifest.v1+json,application/vnd.docker.distribution.manifest.list.v2+json,application/vnd.oci.image.index.v1+json"
              url="https://${registry}/v2/${name}/manifests/${tag}"

              headers="$(curl -sS -I -H "Accept: ${accept}" "${url}" | tr -d '\r' || true)"
              if echo "$headers" | grep -qi '^docker-content-digest:'; then
                digest="$(echo "$headers" | grep -i '^docker-content-digest:' | awk '{print $2}' | head -n1)"
              else
                www="$(echo "$headers" | grep -i '^www-authenticate:' | head -n1 || true)"
                realm="$(echo "$www" | sed -n 's/.*realm="\\([^"]*\\)".*/\\1/p')"
                service="$(echo "$www" | sed -n 's/.*service="\\([^"]*\\)".*/\\1/p')"
                scope="$(echo "$www" | sed -n 's/.*scope="\\([^"]*\\)".*/\\1/p')"
                if [ -n "$realm" ]; then
                  token="$(curl -sSf "${realm}?service=${service}&scope=${scope}" | jq -r '.token // .access_token // empty' || true)"
                else
                  token=""
                fi
                if [ -n "$token" ]; then
                  headers="$(curl -sS -I -H "Accept: ${accept}" -H "Authorization: Bearer ${token}" "${url}" | tr -d '\r' || true)"
                  digest="$(echo "$headers" | grep -i '^docker-content-digest:' | awk '{print $2}' | head -n1)"
                else
                  digest=""
                fi
              fi

              if [ -n "${digest:-}" ]; then
                echo "ghcr.io/${name}@${digest}"
                return 0
              fi

              echo "Waiting for $image_tag to be pullable... ($attempt/$attempts)"
              sleep "$delay"
            done

            echo "::error::Failed to pull $image_tag after $attempts attempts"
            return 1
          }

          CONTROL_PLANE_TAG="ghcr.io/${GITHUB_REPOSITORY}/control-plane:${GITHUB_SHA}"
          MEASURER_TAG="ghcr.io/${GITHUB_REPOSITORY}/measuring-enclave:${GITHUB_SHA}"

          CONTROL_PLANE_IMAGE="$(resolve_digest_ref "$CONTROL_PLANE_TAG")"
          MEASURER_IMAGE="$(resolve_digest_ref "$MEASURER_TAG")"

          echo "Resolved control plane: $CONTROL_PLANE_TAG -> $CONTROL_PLANE_IMAGE"
          echo "Resolved measurer: $MEASURER_TAG -> $MEASURER_IMAGE"

          echo "CONTROL_PLANE_IMAGE=$CONTROL_PLANE_IMAGE" >> "$GITHUB_ENV"
          echo "MEASURER_IMAGE=$MEASURER_IMAGE" >> "$GITHUB_ENV"

      # ---- Deploy ----

      - name: Deploy and bootstrap
        env:
          TRUSTED_AGENT_MRTDS: ${{ steps.measure.outputs.mrtds || steps.measure.outputs.mrtd }}
          TRUSTED_AGENT_MRTDS_BY_SIZE: ${{ steps.measure.outputs.mrtds_by_size }}
          TRUSTED_AGENT_RTMRS: ${{ steps.measure.outputs.rtmrs }}
          TRUSTED_AGENT_RTMRS_BY_SIZE: ${{ steps.measure.outputs.rtmrs_by_size }}
          NUM_TINY_AGENTS: "1"
          NUM_STANDARD_AGENTS: "0"
          NUM_LLM_AGENTS: "0"
          # TODO(azure): re-enable Azure agent launch once Azure confidential VM reliability is fixed.
        run: ./scripts/ci-deploy.sh
