# Staging Rollout
#
# Canonical staging network pipeline:
# 1) Trigger on push to main (in parallel with CI).
# 2) Wait for CI success on the same commit SHA.
# 3) CI builds/pins a staging GCP image for that exact commit.
# 4) Bootstrap an isolated staging-candidate control plane and run builtin deploy examples.
# 5) Promote app-staging DNS alias to the validated candidate network.
#
# Staging profile is intentionally no-cost:
# - billing disabled
# - billing simulation enabled

name: Staging Rollout

on:
  push:
    branches: [main]
    paths:
      - "app/**"
      - "infra/**"
      - "scripts/**"
      - "tests/**"
      - "sdk/**"
      - ".github/actions/**"
      - ".github/workflows/**"
      - "Dockerfile"
      - "docker-compose.yml"
      - "requirements.txt"
      - "pyproject.toml"
  workflow_dispatch:
    inputs:
      cp_url:
        description: "Staging control plane URL"
        required: false
        default: ""
      cp_expected_git_sha:
        description: "Expected git SHA in /health (optional; empty skips check)"
        required: false
        default: ""
      source_ref:
        description: "Git ref to checkout for deploy examples"
        required: false
        default: ""
      control_plane_image:
        description: "Control plane image override"
        required: false
        default: ""

concurrency:
  group: easyenclave-staging-rollout
  cancel-in-progress: true

jobs:
  resolve:
    name: Resolve staging rollout config
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      cp_url: ${{ steps.resolve.outputs.cp_url }}
      cp_expected_git_sha: ${{ steps.resolve.outputs.cp_expected_git_sha }}
      source_ref: ${{ steps.resolve.outputs.source_ref }}
      source_sha: ${{ steps.resolve.outputs.source_sha }}
      staging_domain: ${{ steps.resolve.outputs.staging_domain }}
      staging_network_name: ${{ steps.resolve.outputs.staging_network_name }}
      staging_release_tag: ${{ steps.resolve.outputs.staging_release_tag }}
      should_run: ${{ steps.resolve.outputs.should_run }}
      skip_reason: ${{ steps.resolve.outputs.skip_reason }}
    steps:
      - name: Resolve URLs and refs
        id: resolve
        shell: bash
        env:
          INPUT_CP_URL: ${{ github.event.inputs.cp_url || '' }}
          INPUT_EXPECTED_SHA: ${{ github.event.inputs.cp_expected_git_sha || '' }}
          INPUT_SOURCE_REF: ${{ github.event.inputs.source_ref || '' }}
          GH_TOKEN: ${{ github.token }}
          DEFAULT_DOMAIN: ${{ vars.STAGING_EASYENCLAVE_DOMAIN || 'easyenclave.com' }}
          DEFAULT_NETWORK_NAME: ${{ vars.STAGING_NETWORK_NAME || '' }}
          DEFAULT_CP_URL: ${{ vars.STAGING_CP_URL || '' }}
          PROD_DEFAULT_DOMAIN: ${{ vars.PRODUCTION_EASYENCLAVE_DOMAIN || 'easyenclave.com' }}
          PROD_DEFAULT_CP_URL: ${{ vars.PRODUCTION_CP_URL || '' }}
        run: |
          set -euo pipefail
          make_network_name() {
            local seed="$1"
            local hash adjective_idx noun_idx suffix
            local -a adjectives=(trippy lucid nebula prism velvet cosmic solar ember aurora nova)
            local -a nouns=(voyager horizon drifter comet pulse atlas relay beacon vertex spectrum)
            hash="$(printf '%s' "$seed" | sha256sum | awk '{print $1}')"
            adjective_idx=$((16#${hash:0:2} % ${#adjectives[@]}))
            noun_idx=$((16#${hash:2:2} % ${#nouns[@]}))
            suffix="${hash:4:6}"
            printf '%s-%s-%s' "${adjectives[$adjective_idx]}" "${nouns[$noun_idx]}" "$suffix"
          }

          normalize_network_name() {
            printf '%s' "$1" \
              | tr '[:upper:]' '[:lower:]' \
              | sed -E 's/[^a-z0-9-]+/-/g; s/^-+//; s/-+$//; s/-{2,}/-/g'
          }

          resolve_ref_sha() {
            local ref="$1"
            local sha=""
            if echo "$ref" | grep -Eq '^[0-9a-f]{40}$'; then
              printf '%s' "$ref"
              return 0
            fi
            sha="$(gh api -H "Accept: application/vnd.github+json" "/repos/${GITHUB_REPOSITORY}/commits/${ref}" --jq '.sha' 2>/dev/null || true)"
            if ! echo "${sha:-}" | grep -Eq '^[0-9a-f]{40}$'; then
              return 1
            fi
            printf '%s' "$sha"
          }

          source_ref="${INPUT_SOURCE_REF:-}"
          if [ -z "$source_ref" ]; then
            source_ref="${GITHUB_SHA}"
          fi

          source_sha="$(resolve_ref_sha "$source_ref" || true)"
          if [ -z "${source_sha:-}" ]; then
            echo "::error::Could not resolve source ref '${source_ref}' to a commit SHA."
            exit 1
          fi
          source_ref="$source_sha"

          expected_sha="${INPUT_EXPECTED_SHA:-}"
          if [ -n "$expected_sha" ] && ! echo "$expected_sha" | grep -Eq '^[0-9a-f]{40}$'; then
            expected_sha="$(resolve_ref_sha "$expected_sha" || true)"
          fi
          if [ -z "$expected_sha" ]; then
            expected_sha="$source_sha"
          fi
          if ! echo "$expected_sha" | grep -Eq '^[0-9a-f]{40}$'; then
            echo "::error::Could not resolve expected git SHA."
            exit 1
          fi

          release_seed="${expected_sha:-$source_ref}"
          release_seed="$(normalize_network_name "${release_seed}")"
          if [ -z "$release_seed" ]; then
            release_seed="${GITHUB_RUN_ID}"
          fi
          staging_release_tag="staging-${release_seed:0:20}"

          domain="${DEFAULT_DOMAIN:-easyenclave.com}"
          network_name="$(normalize_network_name "${DEFAULT_NETWORK_NAME:-}")"
          if [ -z "$network_name" ]; then
            network_name="$(make_network_name "staging:${source_ref}:${expected_sha}")"
          fi
          network_name="$(normalize_network_name "$network_name")"
          if [ -z "$network_name" ]; then
            echo "::error::Failed to resolve staging network name"
            exit 1
          fi
          network_name="${network_name:0:48}"
          cp_url="${INPUT_CP_URL:-}"
          if [ -z "$cp_url" ]; then
            cp_url="${DEFAULT_CP_URL:-}"
          fi
          if [ -z "$cp_url" ]; then
            cp_url="https://app-staging.${domain}"
          fi

          prod_domain="${PROD_DEFAULT_DOMAIN:-easyenclave.com}"
          prod_cp_url="${PROD_DEFAULT_CP_URL:-}"
          if [ -z "$prod_cp_url" ]; then
            prod_cp_url="https://app.${prod_domain}"
          fi
          if [ "$cp_url" = "$prod_cp_url" ]; then
            echo "::error::Staging and production CP URLs resolve to the same value: $cp_url"
            echo "::error::Set distinct vars: STAGING_CP_URL/STAGING_EASYENCLAVE_DOMAIN and PRODUCTION_CP_URL/PRODUCTION_EASYENCLAVE_DOMAIN."
            exit 1
          fi
          echo "::notice::Resolved staging network name: ${network_name}"

          should_run="true"
          skip_reason=""

          {
            echo "source_ref=${source_ref}"
            echo "source_sha=${source_sha}"
            echo "cp_expected_git_sha=${expected_sha}"
            echo "staging_domain=${domain}"
            echo "staging_network_name=${network_name}"
            echo "staging_release_tag=${staging_release_tag}"
            echo "cp_url=${cp_url}"
            echo "should_run=${should_run}"
            echo "skip_reason=${skip_reason}"
          } >> "$GITHUB_OUTPUT"

  wait-ci:
    name: Wait for CI on target SHA
    needs: [resolve]
    if: needs.resolve.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
    steps:
      - name: Require CI success for rollout SHA
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          TARGET_SHA: ${{ needs.resolve.outputs.cp_expected_git_sha }}
        run: |
          set -euo pipefail
          if [ -z "${TARGET_SHA:-}" ]; then
            echo "::error::Missing target SHA for CI gate."
            exit 1
          fi

          deadline=$(( $(date +%s) + 3600 ))
          while :; do
            runs="$(gh api -H "Accept: application/vnd.github+json" "/repos/${GITHUB_REPOSITORY}/actions/runs?event=push&head_sha=${TARGET_SHA}&per_page=100")"
            status="$(echo "$runs" | jq -r '[.workflow_runs[] | select(.name == "CI")] | sort_by(.created_at) | last | .status // "missing"')"
            conclusion="$(echo "$runs" | jq -r '[.workflow_runs[] | select(.name == "CI")] | sort_by(.created_at) | last | .conclusion // ""')"
            url="$(echo "$runs" | jq -r '[.workflow_runs[] | select(.name == "CI")] | sort_by(.created_at) | last | .html_url // ""')"
            echo "CI gate: sha=${TARGET_SHA} status=${status} conclusion=${conclusion}"
            if [ -n "$url" ]; then
              echo "  ${url}"
            fi

            if [ "$status" = "completed" ]; then
              if [ "$conclusion" = "success" ]; then
                echo "CI passed for ${TARGET_SHA}."
                break
              fi
              echo "::error::CI for ${TARGET_SHA} completed with conclusion='${conclusion}'."
              exit 1
            fi

            now=$(date +%s)
            if [ "$now" -ge "$deadline" ]; then
              echo "::error::Timed out waiting for CI success for ${TARGET_SHA}."
              exit 1
            fi
            sleep 15
          done

  resolve-ci-artifacts:
    name: Resolve CI rollout artifacts for SHA
    needs: [resolve, wait-ci]
    if: needs.resolve.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
    outputs:
      control_plane_image_digest: ${{ steps.resolve.outputs.control_plane_image_digest }}
      image_project: ${{ steps.resolve.outputs.image_project }}
      image_name: ${{ steps.resolve.outputs.image_name }}
      image_family: ${{ steps.resolve.outputs.image_family }}
      trusted_agent_mrtds: ${{ steps.resolve.outputs.trusted_agent_mrtds }}
      trusted_agent_mrtds_by_size: ${{ steps.resolve.outputs.trusted_agent_mrtds_by_size }}
      trusted_agent_rtmrs: ${{ steps.resolve.outputs.trusted_agent_rtmrs }}
      trusted_agent_rtmrs_by_size: ${{ steps.resolve.outputs.trusted_agent_rtmrs_by_size }}
      hello_tdx_image: ${{ steps.resolve.outputs.hello_tdx_image }}
      private_llm_ollama_image: ${{ steps.resolve.outputs.private_llm_ollama_image }}
      private_llm_model_loader_image: ${{ steps.resolve.outputs.private_llm_model_loader_image }}
    steps:
      - name: Download CI rollout artifact for target SHA
        id: resolve
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          TARGET_SHA: ${{ needs.resolve.outputs.cp_expected_git_sha }}
        run: |
          set -euo pipefail
          if [ -z "${TARGET_SHA:-}" ]; then
            echo "::error::Missing target SHA for rollout artifact lookup."
            exit 1
          fi

          runs="$(gh api -H "Accept: application/vnd.github+json" "/repos/${GITHUB_REPOSITORY}/actions/runs?event=push&head_sha=${TARGET_SHA}&per_page=100")"
          run_id="$(echo "$runs" | jq -r '[.workflow_runs[] | select(.name == "CI" and .conclusion == "success")] | sort_by(.created_at) | last | .id // empty')"
          if [ -z "$run_id" ]; then
            echo "::error::Could not find successful CI run for SHA ${TARGET_SHA}."
            exit 1
          fi

          artifacts="$(gh api -H "Accept: application/vnd.github+json" "/repos/${GITHUB_REPOSITORY}/actions/runs/${run_id}/artifacts?per_page=100")"
          artifact_name="rollout-artifacts-${TARGET_SHA}"
          artifact_id="$(echo "$artifacts" | jq -r --arg n "$artifact_name" '[.artifacts[] | select(.name == $n and .expired == false)] | sort_by(.created_at) | last | .id // empty')"
          if [ -z "$artifact_id" ]; then
            echo "::error::CI run ${run_id} does not contain artifact '${artifact_name}'."
            exit 1
          fi

          zip_path="/tmp/rollout-artifacts.zip"
          out_dir="/tmp/rollout-artifacts"
          rm -rf "$out_dir"
          gh api -H "Accept: application/vnd.github+json" "/repos/${GITHUB_REPOSITORY}/actions/artifacts/${artifact_id}/zip" > "$zip_path"
          unzip -q "$zip_path" -d "$out_dir"
          artifact_json="$(find "$out_dir" -type f -name 'rollout-artifacts.json' | head -n1)"
          if [ -z "${artifact_json:-}" ] || [ ! -f "$artifact_json" ]; then
            echo "::error::rollout-artifacts.json not found in downloaded artifact."
            exit 1
          fi

          artifact_sha="$(jq -r '.git_sha // empty' "$artifact_json")"
          if [ "$artifact_sha" != "$TARGET_SHA" ]; then
            echo "::error::Artifact git_sha mismatch: expected ${TARGET_SHA}, got ${artifact_sha:-<empty>}"
            exit 1
          fi

          {
            echo "control_plane_image_digest=$(jq -r '.control_plane_image_digest' "$artifact_json")"
            echo "image_project=$(jq -r '.gcp_image.image_project' "$artifact_json")"
            echo "image_name=$(jq -r '.gcp_image.image_name' "$artifact_json")"
            echo "image_family=$(jq -r '.gcp_image.image_family' "$artifact_json")"
            echo "trusted_agent_mrtds=$(jq -r '.trusted_values.mrtds' "$artifact_json")"
            echo "trusted_agent_mrtds_by_size=$(jq -c '.trusted_values.mrtds_by_size' "$artifact_json")"
            echo "trusted_agent_rtmrs=$(jq -c '.trusted_values.rtmrs' "$artifact_json")"
            echo "trusted_agent_rtmrs_by_size=$(jq -c '.trusted_values.rtmrs_by_size' "$artifact_json")"
            echo "hello_tdx_image=$(jq -r '.example_images.hello_tdx_image' "$artifact_json")"
            echo "private_llm_ollama_image=$(jq -r '.example_images.private_llm_ollama_image' "$artifact_json")"
            echo "private_llm_model_loader_image=$(jq -r '.example_images.private_llm_model_loader_image' "$artifact_json")"
          } >> "$GITHUB_OUTPUT"

  cleanup-staging-gcp:
    name: Cleanup stale staging GCP resources
    needs: [resolve]
    if: needs.resolve.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      GCP_PROJECT_ID: eestaging
      GCP_SERVICE_ACCOUNT_KEY: ${{ secrets.STAGING_GCP_SERVICE_ACCOUNT_KEY }}
    steps:
      - name: Validate staging GCP config
        id: cfg
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${GCP_SERVICE_ACCOUNT_KEY:-}" ]; then
            echo "::notice::Skipping staging GCP cleanup: STAGING_GCP_SERVICE_ACCOUNT_KEY not configured."
            echo "configured=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "configured=true" >> "$GITHUB_OUTPUT"

      - name: Authenticate to GCP (staging)
        if: steps.cfg.outputs.configured == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ env.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Set up gcloud (staging)
        if: steps.cfg.outputs.configured == 'true'
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Delete previous staging managed instances
        if: steps.cfg.outputs.configured == 'true'
        shell: bash
        run: |
          set -euo pipefail
          echo "Project: ${GCP_PROJECT_ID}"
          mapfile -t instances < <(gcloud compute instances list \
            --project "${GCP_PROJECT_ID}" \
            --filter "labels.easyenclave=managed" \
            --format "value(name,zone.basename())")
          if [ "${#instances[@]}" -eq 0 ]; then
            echo "No managed staging instances to delete."
            exit 0
          fi
          for row in "${instances[@]}"; do
            [ -n "$row" ] || continue
            name="$(echo "$row" | awk '{print $1}')"
            zone="$(echo "$row" | awk '{print $2}')"
            [ -n "$name" ] || continue
            [ -n "$zone" ] || continue
            echo "Deleting stale staging instance: ${name} (${zone})"
            gcloud compute instances delete "${name}" \
              --project "${GCP_PROJECT_ID}" \
              --zone "${zone}" \
              --quiet
          done

      - name: Keep only latest 3 staging commit images
        if: steps.cfg.outputs.configured == 'true'
        shell: bash
        run: |
          set -euo pipefail
          mapfile -t images < <(gcloud compute images list \
            --project "${GCP_PROJECT_ID}" \
            --filter "name~^easyenclave-agent-main-" \
            --sort-by "~creationTimestamp" \
            --format "value(name)")
          if [ "${#images[@]}" -le 3 ]; then
            echo "Staging image cleanup not required."
            exit 0
          fi
          for old in "${images[@]:3}"; do
            [ -n "$old" ] || continue
            echo "Deleting stale staging image: ${old}"
            gcloud compute images delete "${old}" \
              --project "${GCP_PROJECT_ID}" \
              --quiet
          done

  verify-staging-gcp-image:
    name: Verify CI-built staging GCP image exists
    needs: [resolve, wait-ci, resolve-ci-artifacts]
    if: needs.resolve.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      GCP_PROJECT_ID: ${{ needs['resolve-ci-artifacts'].outputs.image_project }}
      GCP_IMAGE_NAME: ${{ needs['resolve-ci-artifacts'].outputs.image_name }}
      GCP_SERVICE_ACCOUNT_KEY: ${{ secrets.STAGING_GCP_SERVICE_ACCOUNT_KEY }}
    steps:
      - name: Validate staging GCP config
        shell: bash
        run: |
          set -euo pipefail
          for v in GCP_PROJECT_ID GCP_IMAGE_NAME GCP_SERVICE_ACCOUNT_KEY; do
            if [ -z "${!v:-}" ]; then
              echo "::error::Missing required value: $v"
              exit 1
            fi
          done

      - name: Authenticate to GCP (staging)
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ env.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Set up gcloud (staging)
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Require CI-built image for rollout commit
        shell: bash
        run: |
          set -euo pipefail
          if ! gcloud compute images describe "${GCP_IMAGE_NAME}" --project "${GCP_PROJECT_ID}" >/dev/null 2>&1; then
            echo "::error::Missing CI-built staging image '${GCP_PROJECT_ID}/${GCP_IMAGE_NAME}'."
            echo "::error::CI must create this image before GCP deploy can run."
            exit 1
          fi
          echo "Found CI-built staging image: ${GCP_PROJECT_ID}/${GCP_IMAGE_NAME}"

  bootstrap:
    name: Bootstrap staging control plane
    needs: [resolve, wait-ci, resolve-ci-artifacts, cleanup-staging-gcp]
    if: needs.resolve.outputs.should_run == 'true'
    uses: ./.github/workflows/bootstrap-control-plane.yml
    secrets: inherit
    with:
      source_ref: ${{ needs.resolve.outputs.source_sha }}
      control_plane_image: ${{ github.event.inputs.control_plane_image || needs['resolve-ci-artifacts'].outputs.control_plane_image_digest }}
      cp_bootstrap_sizes: tiny
      # Keep staging warm spare footprint small.
      num_tiny_agents: '1'
      num_standard_agents: '0'
      num_llm_agents: '0'
      easyenclave_domain: ${{ needs.resolve.outputs.staging_domain }}
      easyenclave_network_name: ${{ needs.resolve.outputs.staging_network_name }}
      easyenclave_release_tag: ${{ needs.resolve.outputs.staging_release_tag }}
      easyenclave_env: staging-candidate
      tcb_enforcement_mode: warn
      allowed_tcb_statuses: UpToDate
      # Staging is intentionally non-production: keep nonce enforcement permissive
      # so bootstrap can proceed even when attester-held-data propagation is flaky.
      nonce_enforcement_mode: optional
      nonce_ttl_seconds: '300'
      rtmr_enforcement_mode: warn
      signature_verification_mode: warn
      cp_to_agent_attestation_mode: optional
      auth_require_github_oauth_in_production: ${{ 'false' }}
      password_login_enabled: ${{ 'true' }}
      auth_allow_password_login_in_production: ${{ 'true' }}
      billing_enabled: ${{ 'false' }}
      billing_capacity_request_dev_simulation: ${{ 'true' }}
      billing_platform_account_id: ''
      billing_contributor_pool_bps: '0'
      use_precomputed_trusted_values: ${{ 'true' }}
      trusted_agent_mrtds: ${{ needs['resolve-ci-artifacts'].outputs.trusted_agent_mrtds }}
      trusted_agent_mrtds_by_size: ${{ needs['resolve-ci-artifacts'].outputs.trusted_agent_mrtds_by_size }}
      trusted_agent_rtmrs: ${{ needs['resolve-ci-artifacts'].outputs.trusted_agent_rtmrs }}
      trusted_agent_rtmrs_by_size: ${{ needs['resolve-ci-artifacts'].outputs.trusted_agent_rtmrs_by_size }}
      ee_gcp_image_project: ${{ needs['resolve-ci-artifacts'].outputs.image_project }}
      ee_gcp_image_name: ${{ needs['resolve-ci-artifacts'].outputs.image_name }}
      ee_gcp_image_family: ${{ needs['resolve-ci-artifacts'].outputs.image_family }}

  deploy-baremetal:
    name: Builtin deploy examples (baremetal)
    needs: [resolve, resolve-ci-artifacts, bootstrap]
    uses: ./.github/workflows/deploy-examples.yml
    secrets: inherit
    with:
      cp_url: ${{ needs.bootstrap.outputs.cp_public_url || needs.bootstrap.outputs.cp_url || needs.resolve.outputs.cp_url }}
      cp_expected_git_sha: ${{ needs.resolve.outputs.cp_expected_git_sha }}
      cp_expected_boot_id: ${{ format('bootstrap-{0}-{1}', github.run_id, github.run_attempt) }}
      source_ref: ${{ needs.resolve.outputs.source_sha }}
      hello_tdx_image: ${{ needs['resolve-ci-artifacts'].outputs.hello_tdx_image }}
      private_llm_ollama_image: ${{ needs['resolve-ci-artifacts'].outputs.private_llm_ollama_image }}
      private_llm_model_loader_image: ${{ needs['resolve-ci-artifacts'].outputs.private_llm_model_loader_image }}
      easyenclave_env: staging

  deploy-gcp:
    name: Builtin deploy examples (gcp)
    needs: [resolve, resolve-ci-artifacts, bootstrap, verify-staging-gcp-image]
    uses: ./.github/workflows/deploy-examples-gcp.yml
    secrets: inherit
    with:
      cp_url: ${{ needs.bootstrap.outputs.cp_public_url || needs.bootstrap.outputs.cp_url || needs.resolve.outputs.cp_url }}
      cp_expected_git_sha: ${{ needs.resolve.outputs.cp_expected_git_sha }}
      cp_expected_boot_id: ${{ format('bootstrap-{0}-{1}', github.run_id, github.run_attempt) }}
      source_ref: ${{ needs.resolve.outputs.source_sha }}
      hello_tdx_image: ${{ needs['resolve-ci-artifacts'].outputs.hello_tdx_image }}
      private_llm_ollama_image: ${{ needs['resolve-ci-artifacts'].outputs.private_llm_ollama_image }}
      private_llm_model_loader_image: ${{ needs['resolve-ci-artifacts'].outputs.private_llm_model_loader_image }}
      easyenclave_env: staging

  cleanup-legacy-gcp-agents:
    name: Cleanup legacy staging GCP agent rows
    needs: [resolve, bootstrap, deploy-baremetal, deploy-gcp]
    if: needs.resolve.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Delete stale legacy vm_name agent rows (tdx-agent-*)
        shell: bash
        env:
          CP_URL: ${{ needs.bootstrap.outputs.cp_public_url || needs.bootstrap.outputs.cp_url || needs.resolve.outputs.cp_url }}
          CP_ADMIN_TOKEN: ${{ secrets.CP_ADMIN_TOKEN }}
          CP_ADMIN_PASSWORD: ${{ secrets.CP_ADMIN_PASSWORD }}
        run: |
          set -euo pipefail
          if [ -z "${CP_URL:-}" ]; then
            echo "::error::Missing CP URL for cleanup."
            exit 1
          fi
          token="$(echo "${CP_ADMIN_TOKEN:-}" | xargs)"
          if [ -z "$token" ]; then
            if [ -z "${CP_ADMIN_PASSWORD:-}" ]; then
              echo "::error::Missing CP_ADMIN_PASSWORD (and CP_ADMIN_TOKEN empty); cannot authenticate cleanup."
              exit 1
            fi
            payload_login="$(jq -cn --arg p "${CP_ADMIN_PASSWORD}" '{password: $p}')"
            token="$(curl -sS -X POST "$CP_URL/admin/login" -H 'Content-Type: application/json' -d "$payload_login" | jq -r '.token // empty' 2>/dev/null || true)"
          fi
          if [ -z "$token" ]; then
            echo "::error::Failed to mint admin token via $CP_URL/admin/login for cleanup."
            exit 1
          fi
          echo "::add-mask::$token"
          ADMIN_TOKEN="$token"

          agents_json="$(curl -sSf -H "Authorization: Bearer ${ADMIN_TOKEN}" -H 'Accept: application/json' "$CP_URL/api/v1/agents")"
          mapfile -t stale_ids < <(
            echo "$agents_json" | jq -r '
              [.agents[]?
                | select((.datacenter // "" | ascii_downcase) | startswith("gcp:"))
                | select((.vm_name // "") | startswith("tdx-agent-"))
                | select((.status // "" | ascii_downcase) == "undeployed" or (.status // "" | ascii_downcase) == "unverified")
                | select((.current_deployment_id // "") == "")
                | .agent_id] | unique[]?'
          )

          if [ "${#stale_ids[@]}" -eq 0 ]; then
            echo "No legacy staging gcp tdx-agent-* rows to clean up."
            exit 0
          fi

          reason="staging-rollout:cleanup-legacy-gcp-vm-name"
          payload="$(jq -cn --arg reason "$reason" '{dry_run:false, reason:$reason}')"
          failed=0
          echo "Cleaning ${#stale_ids[@]} legacy GCP agent row(s)..."
          for agent_id in "${stale_ids[@]}"; do
            code="$(curl -sS -o /tmp/cleanup-agent.json -w "%{http_code}" \
              -X POST "$CP_URL/api/v1/admin/agents/${agent_id}/cleanup" \
              -H "Authorization: Bearer ${ADMIN_TOKEN}" \
              -H 'Content-Type: application/json' \
              -d "$payload" || echo 000)"
            if [ "$code" -ge 400 ]; then
              echo "::error::Cleanup failed for agent=${agent_id} (HTTP $code): $(cat /tmp/cleanup-agent.json)"
              failed=1
            else
              echo "Cleanup succeeded for agent=${agent_id} (HTTP $code)."
            fi
          done

          if [ "$failed" -ne 0 ]; then
            echo "::error::One or more legacy GCP agent cleanups failed."
            exit 1
          fi

  promote-staging-alias:
    name: Promote candidate network to app-staging alias
    needs: [resolve, bootstrap, deploy-baremetal, deploy-gcp, cleanup-legacy-gcp-agents]
    if: needs.resolve.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    env:
      CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CF_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      STAGING_DOMAIN: ${{ needs.resolve.outputs.staging_domain }}
      CANDIDATE_NETWORK_NAME: ${{ needs.resolve.outputs.staging_network_name }}
      EXPECTED_SHA: ${{ needs.resolve.outputs.cp_expected_git_sha }}
    steps:
      - name: Promote app-staging DNS to candidate tunnel target
        shell: bash
        run: |
          set -euo pipefail
          for v in CF_API_TOKEN CF_ZONE_ID STAGING_DOMAIN CANDIDATE_NETWORK_NAME; do
            if [ -z "${!v:-}" ]; then
              echo "::error::Missing required value: $v"
              exit 1
            fi
          done

          candidate_host="${CANDIDATE_NETWORK_NAME}.${STAGING_DOMAIN}"
          staging_alias="app-staging.${STAGING_DOMAIN}"
          base="https://api.cloudflare.com/client/v4/zones/${CF_ZONE_ID}/dns_records"
          auth=(-H "Authorization: Bearer ${CF_API_TOKEN}" -H "Content-Type: application/json")

          candidate_json="$(curl -fsS "${auth[@]}" "${base}?type=CNAME&name=${candidate_host}")"
          candidate_content="$(echo "$candidate_json" | jq -r --arg n "$candidate_host" '.result[] | select((.name | ascii_downcase) == ($n | ascii_downcase)) | .content' | head -n1)"
          if [ -z "${candidate_content:-}" ]; then
            echo "::error::Candidate canonical DNS record not found: ${candidate_host}"
            exit 1
          fi
          if ! echo "$candidate_content" | grep -q '\.cfargotunnel\.com$'; then
            echo "::error::Candidate DNS record does not point to a tunnel target: ${candidate_content}"
            exit 1
          fi

          alias_json="$(curl -fsS "${auth[@]}" "${base}?type=CNAME&name=${staging_alias}")"
          alias_id="$(echo "$alias_json" | jq -r --arg n "$staging_alias" '.result[] | select((.name | ascii_downcase) == ($n | ascii_downcase)) | .id' | head -n1)"
          payload="$(jq -cn --arg name "$staging_alias" --arg content "$candidate_content" '{type:"CNAME", name:$name, content:$content, proxied:true, ttl:1}')"

          if [ -n "${alias_id:-}" ]; then
            curl -fsS -X PATCH "${auth[@]}" --data "$payload" "${base}/${alias_id}" >/dev/null
            echo "Updated ${staging_alias} -> ${candidate_content}"
          else
            curl -fsS -X POST "${auth[@]}" --data "$payload" "${base}" >/dev/null
            echo "Created ${staging_alias} -> ${candidate_content}"
          fi

      - name: Verify promoted staging alias serves expected control plane
        shell: bash
        run: |
          set -euo pipefail
          alias_url="https://app-staging.${STAGING_DOMAIN}"
          deadline=$(( $(date +%s) + 300 ))
          while :; do
            body="$(curl -fsS "${alias_url}/health" 2>/dev/null || true)"
            sha="$(echo "${body:-}" | jq -r '.git_sha // empty' 2>/dev/null || true)"
            if [ -n "${body:-}" ]; then
              if [ -z "${EXPECTED_SHA:-}" ] || [ "${sha:-}" = "${EXPECTED_SHA}" ]; then
                echo "Promoted staging alias is healthy at ${alias_url} (git_sha=${sha:-unknown})."
                break
              fi
            fi
            if [ "$(date +%s)" -ge "$deadline" ]; then
              echo "::error::Timed out verifying promoted staging alias ${alias_url}."
              echo "::error::Expected git_sha='${EXPECTED_SHA:-<any>}' saw='${sha:-<none>}'"
              exit 1
            fi
            sleep 5
          done

  assert-rollout-executed:
    name: Assert staging rollout executed
    needs: [resolve, bootstrap, deploy-baremetal, deploy-gcp, cleanup-legacy-gcp-agents, promote-staging-alias]
    if: always() && needs.resolve.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Fail if any rollout stage was skipped/failed
        shell: bash
        run: |
          set -euo pipefail
          bootstrap="${{ needs.bootstrap.result }}"
          baremetal="${{ needs['deploy-baremetal'].result }}"
          gcp="${{ needs['deploy-gcp'].result }}"
          cleanup_legacy="${{ needs['cleanup-legacy-gcp-agents'].result }}"
          promote_alias="${{ needs['promote-staging-alias'].result }}"
          echo "bootstrap=${bootstrap} baremetal=${baremetal} gcp=${gcp} cleanup_legacy=${cleanup_legacy} promote_alias=${promote_alias}"
          if [ "$bootstrap" != "success" ] || [ "$baremetal" != "success" ] || [ "$gcp" != "success" ] || [ "$cleanup_legacy" != "success" ] || [ "$promote_alias" != "success" ]; then
            echo "::error::Staging rollout did not fully execute: bootstrap=${bootstrap}, baremetal=${baremetal}, gcp=${gcp}, cleanup_legacy=${cleanup_legacy}, promote_alias=${promote_alias}"
            exit 1
          fi
          echo "Staging rollout executed all required stages."
