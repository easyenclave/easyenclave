# Bootstrap Control Plane (manual)
#
# This is intentionally separate from CI to keep CI fast and to avoid tying
# control-plane uptime to every push.

name: Bootstrap Control Plane

on:
  workflow_dispatch:
    inputs:
      control_plane_image:
        description: "Control plane image ref override (default: :latest)"
        required: false
        default: ""
      cp_bootstrap_sizes:
        description: "Comma-separated measurer bootstrap sizes for tdx_cli control-plane new"
        required: false
        default: "tiny"
      num_tiny_agents:
        description: "Additional tiny agents to launch (beyond bootstrap measurers)"
        required: false
        default: "2"
      num_standard_agents:
        description: "Additional standard agents to launch"
        required: false
        default: "0"
      num_llm_agents:
        description: "Additional llm agents to launch"
        required: false
        default: "0"

concurrency:
  # Serialize workflows that mutate the shared control plane to avoid overlap with Builtin Deploy Examples.
  group: easyenclave-shared-control-plane
  cancel-in-progress: false

jobs:
  bootstrap:
    runs-on: [self-hosted, tdx]
    permissions:
      contents: read

    env:
      # Infra + trust.
      ITA_API_KEY: ${{ secrets.INTEL_API_KEY }}
      # Optional: enable CP-native provisioning (GCP capacity fulfillment) to inject ITA keys into provisioned agent VMs.
      EE_AGENT_ITA_API_KEY: ${{ secrets.INTEL_API_KEY }}

      # Optional: CP-native GCP provisioning credentials (used to fulfill gcp:* launch orders).
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GCP_SERVICE_ACCOUNT_KEY: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      # Cloudflare (public endpoint for https://app.easyenclave.com).
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}

      # GitHub OAuth (admin login + deployer identity).
      # Note: GitHub blocks secret names starting with `GITHUB_`, so we store them as EE_GITHUB_*.
      GITHUB_OAUTH_CLIENT_ID: ${{ secrets.EE_GITHUB_OAUTH_CLIENT_ID }}
      GITHUB_OAUTH_CLIENT_SECRET: ${{ secrets.EE_GITHUB_OAUTH_CLIENT_SECRET }}
      # Optional (defaults to https://app.easyenclave.com/auth/github/callback inside the CP if unset).
      GITHUB_OAUTH_REDIRECT_URI: ${{ secrets.EE_GITHUB_OAUTH_REDIRECT_URI }}

      # Admin allowlist for GitHub OAuth (comma-separated logins).
      ADMIN_GITHUB_LOGINS: ${{ secrets.ADMIN_GITHUB_LOGINS }}

      # Stripe (optional billing).
      STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
      STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}

      # Optional: provide a password admin login for convenience (GitHub OAuth is preferred).
      ADMIN_PASSWORD: ${{ secrets.CP_ADMIN_PASSWORD }}

      # Deployer settings.
      CP_BOOTSTRAP_SIZES: ${{ github.event.inputs.cp_bootstrap_sizes || 'tiny' }}
      NUM_TINY_AGENTS: ${{ github.event.inputs.num_tiny_agents || '2' }}
      NUM_STANDARD_AGENTS: ${{ github.event.inputs.num_standard_agents || '0' }}
      NUM_LLM_AGENTS: ${{ github.event.inputs.num_llm_agents || '0' }}

      # Manual bootstraps default to :latest (upgrade-by-default). CI pins to :sha.
      CONTROL_PLANE_IMAGE: ${{ github.event.inputs.control_plane_image || format('ghcr.io/{0}/control-plane:latest', github.repository) }}
      # Control plane measures app versions directly; measurer image is no longer required.

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          set -euo pipefail
          for v in ITA_API_KEY CLOUDFLARE_API_TOKEN CLOUDFLARE_ACCOUNT_ID CLOUDFLARE_ZONE_ID; do
            if [ -z "${!v:-}" ]; then
              echo "::error::Missing required secret/env: $v"
              exit 1
            fi
          done

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Derive ADMIN_PASSWORD_HASH (for control plane container)
        run: |
          set -euo pipefail
          if [ -z "${ADMIN_PASSWORD:-}" ]; then
            echo "ADMIN_PASSWORD not set; skipping password-login configuration."
            exit 0
          fi
          python3 - <<'PY'
          import os
          import bcrypt
          pw = os.environ.get("ADMIN_PASSWORD", "").encode()
          if not pw:
            raise SystemExit("ADMIN_PASSWORD missing")
          hashed = bcrypt.hashpw(pw, bcrypt.gensalt()).decode()
          # Write to GITHUB_ENV without printing the value to logs.
          with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as f:
            f.write("ADMIN_PASSWORD_HASH=" + hashed + "\n")
          PY

      - name: Cleanup leaked measurement VMs (best effort)
        run: |
          set -euo pipefail
          if command -v virsh >/dev/null 2>&1; then
            for d in $(virsh list --all --name | grep '^tdvirsh-trust_domain_verity-' || true); do
              [ -n "$d" ] || continue
              virsh destroy "$d" >/dev/null 2>&1 || true
              virsh undefine "$d" --nvram >/dev/null 2>&1 || virsh undefine "$d" >/dev/null 2>&1 || true
            done
          fi

      - name: Build and measure trusted values (bootstrap sizes)
        id: measure
        env:
          MEASURE_SIZES: ${{ github.event.inputs.cp_bootstrap_sizes || 'tiny' }}
        run: ./scripts/ci-build-measure.sh

      - name: Deploy control plane + bootstrap agents/apps
        env:
          TRUSTED_AGENT_MRTDS: ${{ steps.measure.outputs.mrtds }}
          # Quote JSON-like strings to prevent YAML from parsing them as flow mappings.
          TRUSTED_AGENT_MRTDS_BY_SIZE: '${{ steps.measure.outputs.mrtds_by_size }}'
          TRUSTED_AGENT_RTMRS: '${{ steps.measure.outputs.rtmrs }}'
          TRUSTED_AGENT_RTMRS_BY_SIZE: '${{ steps.measure.outputs.rtmrs_by_size }}'
        run: ./scripts/ci-deploy.sh
