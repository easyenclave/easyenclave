# Bootstrap Control Plane
#
# Reusable network bootstrap for staging/production profiles.

name: Bootstrap Control Plane

on:
  workflow_call:
    inputs:
      source_ref:
        required: false
        type: string
        default: ""
      control_plane_image:
        required: false
        type: string
        default: ""
      cp_bootstrap_sizes:
        required: false
        type: string
        default: "tiny"
      num_tiny_agents:
        required: false
        type: string
        default: "2"
      num_standard_agents:
        required: false
        type: string
        default: "0"
      num_llm_agents:
        required: false
        type: string
        default: "0"
      easyenclave_domain:
        required: false
        type: string
        default: "easyenclave.com"
      easyenclave_network_name:
        required: false
        type: string
        default: ""
      easyenclave_env:
        required: false
        type: string
        default: "staging"
      tcb_enforcement_mode:
        required: false
        type: string
        default: "warn"
      allowed_tcb_statuses:
        required: false
        type: string
        default: "UpToDate"
      nonce_enforcement_mode:
        required: false
        type: string
        default: "required"
      nonce_ttl_seconds:
        required: false
        type: string
        default: "300"
      rtmr_enforcement_mode:
        required: false
        type: string
        default: "warn"
      signature_verification_mode:
        required: false
        type: string
        default: "warn"
      cp_to_agent_attestation_mode:
        required: false
        type: string
        default: "optional"
      auth_require_github_oauth_in_production:
        required: false
        type: string
        default: "true"
      password_login_enabled:
        required: false
        type: string
        default: "true"
      auth_allow_password_login_in_production:
        required: false
        type: string
        default: "false"
      billing_enabled:
        required: false
        type: string
        default: "true"
      billing_capacity_request_dev_simulation:
        required: false
        type: string
        default: "true"
      billing_platform_account_id:
        required: false
        type: string
        default: ""
      billing_contributor_pool_bps:
        required: false
        type: string
        default: "5000"
      ee_gcp_image_project:
        required: false
        type: string
        default: ""
      ee_gcp_image_family:
        required: false
        type: string
        default: ""
      ee_gcp_image_name:
        required: false
        type: string
        default: ""
      use_precomputed_trusted_values:
        required: false
        type: string
        default: "false"
      trusted_agent_mrtds:
        required: false
        type: string
        default: ""
      trusted_agent_mrtds_by_size:
        required: false
        type: string
        default: ""
      trusted_agent_rtmrs:
        required: false
        type: string
        default: ""
      trusted_agent_rtmrs_by_size:
        required: false
        type: string
        default: ""
      cosign_certificate_oidc_issuer:
        required: false
        type: string
        default: ""
      cosign_certificate_identity_regexp:
        required: false
        type: string
        default: ""
    outputs:
      cp_url:
        description: "Preferred control-plane URL (public if reachable, else internal)"
        value: ${{ jobs.bootstrap.outputs.cp_url }}
      cp_internal_url:
        description: "Internal control-plane URL on the self-hosted TDX network"
        value: ${{ jobs.bootstrap.outputs.cp_internal_url }}
      cp_public_url:
        description: "Public control-plane URL (empty if not yet reachable)"
        value: ${{ jobs.bootstrap.outputs.cp_public_url }}
      cp_admin_token:
        description: "Bootstrap admin bearer token minted for this control-plane instance"
        value: ${{ jobs.bootstrap.outputs.cp_admin_token }}
  workflow_dispatch:
    inputs:
      source_ref:
        description: "Git ref to checkout before bootstrap (tag/sha/branch)"
        required: false
        default: ""
      control_plane_image:
        description: "Control plane image ref override (default: :latest)"
        required: false
        default: ""
      cp_bootstrap_sizes:
        description: "Comma-separated bootstrap sizes trusted at bring-up"
        required: false
        default: "tiny"
      num_tiny_agents:
        description: "Additional tiny agents to launch"
        required: false
        default: "2"
      num_standard_agents:
        description: "Additional standard agents to launch"
        required: false
        default: "0"
      num_llm_agents:
        description: "Additional llm agents to launch"
        required: false
        default: "0"
      easyenclave_domain:
        description: "Control-plane DNS domain"
        required: false
        default: "easyenclave.com"
      easyenclave_network_name:
        description: "Control-plane network name for tunnel identity isolation"
        required: false
        default: ""
      easyenclave_env:
        description: "Environment profile (staging|production)"
        required: false
        default: "staging"
      tcb_enforcement_mode:
        description: "TCB enforcement mode"
        required: false
        default: "warn"
      allowed_tcb_statuses:
        description: "Allowed attester TCB statuses"
        required: false
        default: "UpToDate"
      nonce_enforcement_mode:
        description: "Nonce enforcement mode"
        required: false
        default: "required"
      nonce_ttl_seconds:
        description: "Nonce TTL in seconds"
        required: false
        default: "300"
      rtmr_enforcement_mode:
        description: "RTMR enforcement mode"
        required: false
        default: "warn"
      signature_verification_mode:
        description: "Signature verification mode"
        required: false
        default: "warn"
      cp_to_agent_attestation_mode:
        description: "CP->agent attestation mode"
        required: false
        default: "optional"
      auth_require_github_oauth_in_production:
        description: "Require GitHub OAuth in production"
        required: false
        default: "true"
      password_login_enabled:
        description: "Enable password login"
        required: false
        default: "true"
      auth_allow_password_login_in_production:
        description: "Allow password login in production"
        required: false
        default: "false"
      billing_enabled:
        description: "Enable billing"
        required: false
        default: "true"
      billing_capacity_request_dev_simulation:
        description: "Simulate billing transactions"
        required: false
        default: "true"
      billing_platform_account_id:
        description: "Platform account id for revenue share"
        required: false
        default: ""
      billing_contributor_pool_bps:
        description: "Contributor pool basis points"
        required: false
        default: "5000"
concurrency:
  group: easyenclave-control-plane-shared-host
  cancel-in-progress: false

jobs:
  bootstrap:
    runs-on: [self-hosted, tdx]
    permissions:
      contents: read
    outputs:
      cp_url: ${{ steps.cp_urls.outputs.cp_url }}
      cp_internal_url: ${{ steps.cp_urls.outputs.cp_internal_url }}
      cp_public_url: ${{ steps.cp_urls.outputs.cp_public_url }}
      cp_admin_token: ${{ steps.admin_token.outputs.cp_admin_token }}

    env:
      EASYENCLAVE_BOOT_ID: bootstrap-${{ github.run_id }}-${{ github.run_attempt }}

      # Infra + trust.
      INTEL_API_KEY: ${{ secrets.INTEL_API_KEY }}
      ITA_API_KEY: ${{ secrets.INTEL_API_KEY }}
      EE_AGENT_ITA_API_KEY: ${{ secrets.INTEL_API_KEY }}

      # Optional: CP-native GCP provisioning credentials (used to fulfill gcp:* launch orders).
      # Prefer environment-specific secrets when present, falling back to legacy shared ones.
      # This lets staging/prod run in different GCP projects while keeping backwards compatibility.
      GCP_PROJECT_ID: ${{ ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') == 'production' && (secrets.PRODUCTION_GCP_PROJECT_ID || secrets.GCP_PROJECT_ID)) || ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') != 'production' && (secrets.STAGING_GCP_PROJECT_ID || secrets.GCP_PROJECT_ID)) || secrets.GCP_PROJECT_ID }}
      GCP_SERVICE_ACCOUNT_KEY: ${{ ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') == 'production' && (secrets.PRODUCTION_GCP_SERVICE_ACCOUNT_KEY || secrets.GCP_SERVICE_ACCOUNT_KEY)) || ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') != 'production' && (secrets.STAGING_GCP_SERVICE_ACCOUNT_KEY || secrets.GCP_SERVICE_ACCOUNT_KEY)) || secrets.GCP_SERVICE_ACCOUNT_KEY }}

      # Shared Cloudflare credentials; network separation is done by domain/hostname.
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      EASYENCLAVE_DOMAIN: ${{ inputs.easyenclave_domain || github.event.inputs.easyenclave_domain || 'easyenclave.com' }}
      EASYENCLAVE_NETWORK_NAME: ${{ inputs.easyenclave_network_name || github.event.inputs.easyenclave_network_name || '' }}

      # GitHub OAuth (admin login + deployer identity).
      # Prefer env-specific OAuth app credentials for simultaneous staging/prod.
      GITHUB_OAUTH_CLIENT_ID: ${{ ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') == 'production' && (secrets.PRODUCTION_EE_GITHUB_OAUTH_CLIENT_ID || secrets.EE_GITHUB_OAUTH_CLIENT_ID)) || ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') != 'production' && (secrets.STAGING_EE_GITHUB_OAUTH_CLIENT_ID || secrets.EE_GITHUB_OAUTH_CLIENT_ID)) || secrets.EE_GITHUB_OAUTH_CLIENT_ID }}
      GITHUB_OAUTH_CLIENT_SECRET: ${{ ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') == 'production' && (secrets.PRODUCTION_EE_GITHUB_OAUTH_CLIENT_SECRET || secrets.EE_GITHUB_OAUTH_CLIENT_SECRET)) || ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') != 'production' && (secrets.STAGING_EE_GITHUB_OAUTH_CLIENT_SECRET || secrets.EE_GITHUB_OAUTH_CLIENT_SECRET)) || secrets.EE_GITHUB_OAUTH_CLIENT_SECRET }}
      # Resolved per-environment below (staging vs production) to avoid callback mismatch.
      GITHUB_OAUTH_REDIRECT_URI: ${{ secrets.EE_GITHUB_OAUTH_REDIRECT_URI }}
      ADMIN_GITHUB_LOGINS: ${{ secrets.ADMIN_GITHUB_LOGINS }}

      # Stripe (optional billing).
      STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
      STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}

      # Required for CI/bootstrap automation that performs admin-only control-plane actions.
      ADMIN_PASSWORD: ${{ secrets.CP_ADMIN_PASSWORD }}

      # Deployer settings.
      CP_BOOTSTRAP_SIZES: ${{ inputs.cp_bootstrap_sizes || github.event.inputs.cp_bootstrap_sizes || 'tiny' }}
      NUM_TINY_AGENTS: ${{ inputs.num_tiny_agents || github.event.inputs.num_tiny_agents || '2' }}
      NUM_STANDARD_AGENTS: ${{ inputs.num_standard_agents || github.event.inputs.num_standard_agents || '0' }}
      NUM_LLM_AGENTS: ${{ inputs.num_llm_agents || github.event.inputs.num_llm_agents || '0' }}

      # Workflow_call rollouts pin image explicitly; manual default remains :latest.
      CONTROL_PLANE_IMAGE: ${{ inputs.control_plane_image || github.event.inputs.control_plane_image || format('ghcr.io/{0}/control-plane:latest', github.repository) }}

      # Runtime policy profile.
      EASYENCLAVE_ENV: ${{ inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging' }}
      TCB_ENFORCEMENT_MODE: ${{ inputs.tcb_enforcement_mode || github.event.inputs.tcb_enforcement_mode || 'warn' }}
      ALLOWED_TCB_STATUSES: ${{ inputs.allowed_tcb_statuses || github.event.inputs.allowed_tcb_statuses || 'UpToDate' }}
      NONCE_ENFORCEMENT_MODE: ${{ inputs.nonce_enforcement_mode || github.event.inputs.nonce_enforcement_mode || 'required' }}
      NONCE_TTL_SECONDS: ${{ inputs.nonce_ttl_seconds || github.event.inputs.nonce_ttl_seconds || '300' }}
      RTMR_ENFORCEMENT_MODE: ${{ inputs.rtmr_enforcement_mode || github.event.inputs.rtmr_enforcement_mode || 'warn' }}
      SIGNATURE_VERIFICATION_MODE: ${{ inputs.signature_verification_mode || github.event.inputs.signature_verification_mode || 'warn' }}
      CP_TO_AGENT_ATTESTATION_MODE: ${{ inputs.cp_to_agent_attestation_mode || github.event.inputs.cp_to_agent_attestation_mode || 'optional' }}
      AUTH_REQUIRE_GITHUB_OAUTH_IN_PRODUCTION: ${{ inputs.auth_require_github_oauth_in_production || github.event.inputs.auth_require_github_oauth_in_production || 'true' }}
      PASSWORD_LOGIN_ENABLED: ${{ inputs.password_login_enabled || github.event.inputs.password_login_enabled || 'true' }}
      AUTH_ALLOW_PASSWORD_LOGIN_IN_PRODUCTION: ${{ inputs.auth_allow_password_login_in_production || github.event.inputs.auth_allow_password_login_in_production || 'false' }}
      BILLING_ENABLED: ${{ inputs.billing_enabled || github.event.inputs.billing_enabled || 'true' }}
      BILLING_CAPACITY_REQUEST_DEV_SIMULATION: ${{ inputs.billing_capacity_request_dev_simulation || github.event.inputs.billing_capacity_request_dev_simulation || 'true' }}
      BILLING_PLATFORM_ACCOUNT_ID: ${{ inputs.billing_platform_account_id || github.event.inputs.billing_platform_account_id || secrets.BILLING_PLATFORM_ACCOUNT_ID || '' }}
      BILLING_CONTRIBUTOR_POOL_BPS: ${{ inputs.billing_contributor_pool_bps || github.event.inputs.billing_contributor_pool_bps || '5000' }}
      DEFAULT_GCP_TINY_CAPACITY_ENABLED: ${{ ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') == 'production' && 'true') || 'false' }}
      DEFAULT_GCP_TINY_CAPACITY_COUNT: ${{ ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') == 'production' && '1') || '0' }}
      DEFAULT_GCP_TINY_CAPACITY_DISPATCH: ${{ ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') == 'production' && 'true') || 'false' }}
      EE_GCP_IMAGE_PROJECT: ${{ inputs.ee_gcp_image_project || '' }}
      EE_GCP_IMAGE_FAMILY: ${{ inputs.ee_gcp_image_family || '' }}
      EE_GCP_IMAGE_NAME: ${{ inputs.ee_gcp_image_name || '' }}
      USE_PRECOMPUTED_TRUSTED_VALUES: ${{ inputs.use_precomputed_trusted_values || 'false' }}
      PRECOMPUTED_TRUSTED_AGENT_MRTDS: ${{ inputs.trusted_agent_mrtds || '' }}
      PRECOMPUTED_TRUSTED_AGENT_MRTDS_BY_SIZE: ${{ inputs.trusted_agent_mrtds_by_size || '' }}
      PRECOMPUTED_TRUSTED_AGENT_RTMRS: ${{ inputs.trusted_agent_rtmrs || '' }}
      PRECOMPUTED_TRUSTED_AGENT_RTMRS_BY_SIZE: ${{ inputs.trusted_agent_rtmrs_by_size || '' }}
      COSIGN_CERTIFICATE_OIDC_ISSUER: ${{ inputs.cosign_certificate_oidc_issuer || 'https://token.actions.githubusercontent.com' }}
      COSIGN_CERTIFICATE_IDENTITY_REGEXP: ${{ inputs.cosign_certificate_identity_regexp || '^https://github.com/.+/.+/.github/workflows/.+@refs/.*$' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.source_ref != '' && inputs.source_ref || github.ref }}

      - name: Resolve source git SHA for /health
        shell: bash
        run: |
          set -euo pipefail
          echo "EASYENCLAVE_GIT_SHA=$(git rev-parse HEAD)" >> "$GITHUB_ENV"

      - name: Resolve GitHub OAuth redirect URI (per environment)
        shell: bash
        env:
          STAGING_REDIRECT_OVERRIDE: ${{ secrets.STAGING_EE_GITHUB_OAUTH_REDIRECT_URI || '' }}
          PRODUCTION_REDIRECT_OVERRIDE: ${{ secrets.PRODUCTION_EE_GITHUB_OAUTH_REDIRECT_URI || '' }}
          SHARED_REDIRECT_OVERRIDE: ${{ secrets.EE_GITHUB_OAUTH_REDIRECT_URI || '' }}
        run: |
          set -euo pipefail
          env_name="$(echo "${EASYENCLAVE_ENV:-staging}" | tr '[:upper:]' '[:lower:]')"
          domain="${EASYENCLAVE_DOMAIN:-easyenclave.com}"
          redirect_uri=""

          if [ "$env_name" = "production" ]; then
            redirect_uri="${PRODUCTION_REDIRECT_OVERRIDE:-${SHARED_REDIRECT_OVERRIDE:-}}"
            if [ -z "$redirect_uri" ]; then
              redirect_uri="https://app.${domain}/auth/github/callback"
            fi
          else
            # Never inherit the shared redirect for staging; default to app-staging
            # to avoid callback collisions with production.
            redirect_uri="${STAGING_REDIRECT_OVERRIDE:-}"
            if [ -z "$redirect_uri" ]; then
              redirect_uri="https://app-staging.${domain}/auth/github/callback"
            fi
          fi

          echo "Using GitHub OAuth redirect URI for env='${env_name}': ${redirect_uri}"
          echo "GITHUB_OAUTH_REDIRECT_URI=${redirect_uri}" >> "$GITHUB_ENV"

      - name: Validate required secrets
        run: |
          set -euo pipefail
          for v in ITA_API_KEY CLOUDFLARE_API_TOKEN CLOUDFLARE_ACCOUNT_ID CLOUDFLARE_ZONE_ID ADMIN_PASSWORD; do
            if [ -z "${!v:-}" ]; then
              echo "::error::Missing required secret/env: $v"
              exit 1
            fi
          done

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Derive ADMIN_PASSWORD_HASH (for control plane container)
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import os
          import bcrypt
          pw = os.environ.get("ADMIN_PASSWORD", "").encode()
          if not pw:
            raise SystemExit("ADMIN_PASSWORD missing")
          hashed = bcrypt.hashpw(pw, bcrypt.gensalt()).decode()
          with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as f:
            f.write("ADMIN_PASSWORD_HASH=" + hashed + "\n")
          PY

      - name: Cleanup leaked measurement VMs (best effort)
        if: ${{ vars.EASYENCLAVE_ENABLE_LEAKED_VM_CLEANUP == 'true' }}
        run: |
          set -euo pipefail
          if command -v virsh >/dev/null 2>&1; then
            libvirt_uri="qemu:///system"
            for d in $(virsh --connect "$libvirt_uri" list --all --name | grep '^tdvirsh-trust_domain_verity-' || true); do
              [ -n "$d" ] || continue
              virsh --connect "$libvirt_uri" destroy "$d" >/dev/null 2>&1 || true
              virsh --connect "$libvirt_uri" undefine "$d" --nvram >/dev/null 2>&1 || virsh --connect "$libvirt_uri" undefine "$d" >/dev/null 2>&1 || true
            done
          fi

      - name: Validate trusted-value source
        shell: bash
        run: |
          set -euo pipefail
          mode="$(echo "${USE_PRECOMPUTED_TRUSTED_VALUES:-false}" | tr '[:upper:]' '[:lower:]')"
          if [ "$mode" != "true" ]; then
            echo "Trusted-value source: local measurement"
            exit 0
          fi

          for v in PRECOMPUTED_TRUSTED_AGENT_MRTDS PRECOMPUTED_TRUSTED_AGENT_MRTDS_BY_SIZE PRECOMPUTED_TRUSTED_AGENT_RTMRS PRECOMPUTED_TRUSTED_AGENT_RTMRS_BY_SIZE; do
            if [ -z "${!v:-}" ]; then
              echo "::error::use_precomputed_trusted_values=true requires $v"
              exit 1
            fi
          done
          echo "${PRECOMPUTED_TRUSTED_AGENT_MRTDS_BY_SIZE}" | jq -e 'type == "object"' >/dev/null
          echo "${PRECOMPUTED_TRUSTED_AGENT_RTMRS}" | jq -e 'type == "object"' >/dev/null
          echo "${PRECOMPUTED_TRUSTED_AGENT_RTMRS_BY_SIZE}" | jq -e 'type == "object"' >/dev/null
          echo "Trusted-value source: precomputed bundle"

      - name: Prune stale local tdvirsh VMs (current + orphaned networks)
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v virsh >/dev/null 2>&1; then
            echo "virsh not found; skipping local VM prune."
            exit 0
          fi
          network_raw="${EASYENCLAVE_NETWORK_NAME:-${EASYENCLAVE_ENV:-network}}"
          network_slug="$(echo "${network_raw}" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9-]+/-/g; s/^-+//; s/-+$//; s/-{2,}/-/g')"
          if [ -z "${network_slug}" ]; then
            echo "No network slug resolved; skipping local VM prune."
            exit 0
          fi
          echo "Pruning stale tdvirsh domains for current network='${network_slug}'"
          count_current=0
          count_orphan=0
          mapfile -t all_domains < <(virsh --connect qemu:///system list --all --name | sed '/^$/d')

          # 1) Always clear stale domains for the network we are about to bootstrap.
          for d in "${all_domains[@]}"; do
            case "$d" in
              tdvirsh-cp-"${network_slug}"-*|tdvirsh-agent-*"${network_slug}"-*)
                echo "  deleting current-network stale domain: $d"
                virsh --connect qemu:///system destroy "$d" >/dev/null 2>&1 || true
                virsh --connect qemu:///system undefine "$d" --nvram >/dev/null 2>&1 || virsh --connect qemu:///system undefine "$d" >/dev/null 2>&1 || true
                count_current=$((count_current + 1))
                ;;
            esac
          done

          # 2) Cleanup orphaned legacy networks.
          # Also cleanup stale same-environment networks even when their CP is still running,
          # so a new staging/prod bootstrap does not stack multiple clusters on one host.
          declare -A network_domains
          declare -A network_has_running_cp
          for d in "${all_domains[@]}"; do
            network=""
            is_cp="false"
            if [[ "$d" =~ ^tdvirsh-cp-(.+)-[0-9a-f]{8}$ ]]; then
              network="${BASH_REMATCH[1]}"
              is_cp="true"
            elif [[ "$d" =~ ^tdvirsh-agent-[^-]+-(.+)-[0-9a-f]{8}$ ]]; then
              network="${BASH_REMATCH[1]}"
            else
              continue
            fi
            network_domains["$network"]+="${d}"$'\n'
            if [ "$is_cp" = "true" ]; then
              state="$(virsh --connect qemu:///system domstate "$d" 2>/dev/null | tr -d '\r' | xargs || true)"
              if [ "$state" = "running" ]; then
                network_has_running_cp["$network"]="1"
              fi
            fi
          done

          env_slug="$(echo "${EASYENCLAVE_ENV:-}" | tr '[:upper:]' '[:lower:]' | xargs)"
          network_is_same_environment() {
            local network="$1"
            local cp_domain=""
            local cp_ip=""
            local health=""
            local proxy_url=""
            local state=""

            [ -n "$env_slug" ] || return 1

            for d in "${all_domains[@]}"; do
              case "$d" in
                tdvirsh-cp-"${network}"-*)
                  state="$(virsh --connect qemu:///system domstate "$d" 2>/dev/null | tr -d '\r' | xargs || true)"
                  if [ "$state" = "running" ]; then
                    cp_domain="$d"
                    break
                  fi
                  ;;
              esac
            done
            [ -n "$cp_domain" ] || return 1

            cp_ip="$(virsh --connect qemu:///system domifaddr "$cp_domain" --source lease 2>/dev/null | awk '/ipv4/ {print $4}' | head -n1 | cut -d/ -f1)"
            [ -n "$cp_ip" ] || return 1

            health="$(curl -fsS --max-time 5 "http://${cp_ip}:8080/health" 2>/dev/null || true)"
            proxy_url="$(echo "${health}" | jq -r '.proxy_url // empty' 2>/dev/null || true)"
            [ -n "$proxy_url" ] || return 1

            case "$env_slug" in
              staging)
                [[ "$proxy_url" == *"app-staging."* ]]
                ;;
              production|prod)
                [[ "$proxy_url" == *"app."* && "$proxy_url" != *"app-staging."* ]]
                ;;
              *)
                return 1
                ;;
            esac
          }

          for network in "${!network_domains[@]}"; do
            if [ "$network" = "$network_slug" ]; then
              continue
            fi
            if [ "${network_has_running_cp[$network]:-0}" = "1" ]; then
              if network_is_same_environment "$network"; then
                echo "  deleting stale same-environment network domains: env=${env_slug} network=${network}"
              else
                continue
              fi
            else
              echo "  deleting orphaned network domains: network=$network"
            fi
            while IFS= read -r d; do
              [ -n "$d" ] || continue
              echo "    deleting orphan domain: $d"
              virsh --connect qemu:///system destroy "$d" >/dev/null 2>&1 || true
              virsh --connect qemu:///system undefine "$d" --nvram >/dev/null 2>&1 || virsh --connect qemu:///system undefine "$d" >/dev/null 2>&1 || true
              count_orphan=$((count_orphan + 1))
            done <<< "${network_domains[$network]}"
          done

          echo "Pruned ${count_current} current-network domain(s) and ${count_orphan} orphan-network domain(s)."

      - name: Build verity artifacts (precomputed mode)
        if: env.USE_PRECOMPUTED_TRUSTED_VALUES == 'true'
        run: |
          set -euo pipefail
          cd infra/image
          nix develop --command make build

      - name: Build and measure trusted values (bootstrap sizes)
        if: env.USE_PRECOMPUTED_TRUSTED_VALUES != 'true'
        id: measure
        env:
          MEASURE_SIZES: ${{ env.CP_BOOTSTRAP_SIZES }}
        run: ./scripts/ci-build-measure.sh

      - name: Deploy control plane + bootstrap agents/apps
        id: deploy
        env:
          TRUSTED_AGENT_MRTDS: ${{ env.PRECOMPUTED_TRUSTED_AGENT_MRTDS || steps.measure.outputs.mrtds }}
          TRUSTED_AGENT_MRTDS_BY_SIZE: '${{ env.PRECOMPUTED_TRUSTED_AGENT_MRTDS_BY_SIZE || steps.measure.outputs.mrtds_by_size }}'
          TRUSTED_AGENT_RTMRS: '${{ env.PRECOMPUTED_TRUSTED_AGENT_RTMRS || steps.measure.outputs.rtmrs }}'
          TRUSTED_AGENT_RTMRS_BY_SIZE: '${{ env.PRECOMPUTED_TRUSTED_AGENT_RTMRS_BY_SIZE || steps.measure.outputs.rtmrs_by_size }}'
        shell: bash
        run: |
          set -euo pipefail
          tiny_required="${NUM_TINY_AGENTS:-0}"
          standard_required="${NUM_STANDARD_AGENTS:-0}"
          llm_required="${NUM_LLM_AGENTS:-0}"
          required_total=$((tiny_required + standard_required + llm_required))

          set +e
          ./scripts/ci-deploy.sh 2>&1 | tee /tmp/ci-deploy.log
          ci_rc=${PIPESTATUS[0]}
          set -e

          if [ "$ci_rc" -ne 0 ]; then
            if grep -q "No agents available (bootstrap=0 and additional requested=0)" /tmp/ci-deploy.log; then
              if [ "${required_total:-0}" -gt 0 ]; then
                echo "::error::ci-deploy.sh skipped agent bootstrap capacity, but rollout requires tiny=${tiny_required} standard=${standard_required} llm=${llm_required}."
                exit "$ci_rc"
              fi
              echo "::warning::ci-deploy.sh skipped agent bootstrap capacity (no startup agents requested)."
            elif grep -q "Not all agents verified after" /tmp/ci-deploy.log \
              && grep -Eq "All [0-9]+ agents verified" /tmp/ci-deploy.log; then
              echo "::warning::Ignoring transient post-loop verification regression from ci-deploy.sh; validating agent capacity directly."
            else
              exit "$ci_rc"
            fi
          fi

          cp_for_check="$(sed -n 's/^Agent registration URL: \(https\?:\/\/[^[:space:]]\+\).*/\1/p' /tmp/ci-deploy.log | tail -n1 | xargs || true)"
          if [ -z "$cp_for_check" ]; then
            cp_for_check="$(sed -n 's/^Control plane URL: \(https\?:\/\/[^[:space:]]\+\).*/\1/p' /tmp/ci-deploy.log | tail -n1 | xargs || true)"
          fi
          if [ -z "$cp_for_check" ]; then
            echo "::error::Could not resolve control-plane URL for post-bootstrap capacity check."
            exit 1
          fi

          verify_counts() {
            local agents_json="$1"
            local size="$2"
            echo "$agents_json" | jq -r --arg s "$size" '
              [.agents[]
                | select(.verified == true)
                | select((.node_size // "" | ascii_downcase) == ($s | ascii_downcase))
                | select((.health_status // "" | ascii_downcase) == "healthy")
              ] | length'
          }

          max_checks=24

          tiny_verified=0
          standard_verified=0
          llm_verified=0

          for attempt in $(seq 1 "$max_checks"); do
            agents_json="$(curl -fsS "$cp_for_check/api/v1/agents" 2>/tmp/bootstrap_agents.err || true)"
            if [ -z "${agents_json:-}" ]; then
              if [ "$attempt" -lt "$max_checks" ]; then
                echo "Post-bootstrap capacity check: agents API not reachable yet ($attempt/$max_checks), retrying..."
                sleep 5
                continue
              fi
              echo "::error::Failed to query agents from $cp_for_check after retries."
              if [ -f /tmp/bootstrap_agents.err ]; then
                cat /tmp/bootstrap_agents.err || true
              fi
              exit 1
            fi

            tiny_verified="$(verify_counts "$agents_json" tiny)"
            standard_verified="$(verify_counts "$agents_json" standard)"
            llm_verified="$(verify_counts "$agents_json" llm)"

            if [ "${tiny_verified:-0}" -ge "$tiny_required" ] \
              && [ "${standard_verified:-0}" -ge "$standard_required" ] \
              && [ "${llm_verified:-0}" -ge "$llm_required" ]; then
              echo "Bootstrap capacity check passed: tiny=${tiny_verified} standard=${standard_verified} llm=${llm_verified}"
              break
            fi

            if [ "$attempt" -eq "$max_checks" ]; then
              echo "::error::Insufficient verified capacity after bootstrap retries."
              echo "::error::tiny=${tiny_verified} (need ${tiny_required}) standard=${standard_verified} (need ${standard_required}) llm=${llm_verified} (need ${llm_required})"
              echo "Latest agent snapshot:"
              echo "$agents_json" | jq -r '
                [.agents[] | {
                  agent_id,
                  node_size,
                  status,
                  health_status,
                  verified,
                  datacenter,
                  verification_error
                }]' || true
              exit 1
            fi

            echo "Post-bootstrap capacity check: tiny=${tiny_verified}/${tiny_required} standard=${standard_verified}/${standard_required} llm=${llm_verified}/${llm_required} (attempt $attempt/$max_checks)"
            sleep 5
          done

      - name: Normalize bootstrap control-plane URLs
        id: cp_urls
        shell: bash
        env:
          DEPLOY_CP_URL: ${{ steps.deploy.outputs.cp_url }}
          DEPLOY_CP_INTERNAL_URL: ${{ steps.deploy.outputs.cp_internal_url }}
          DEPLOY_CP_PUBLIC_URL: ${{ steps.deploy.outputs.cp_public_url }}
        run: |
          set -euo pipefail

          cp_internal="$(echo "${DEPLOY_CP_INTERNAL_URL:-}" | xargs)"
          cp_public="$(echo "${DEPLOY_CP_PUBLIC_URL:-}" | xargs)"
          cp_url="$(echo "${DEPLOY_CP_URL:-}" | xargs)"

          if [ -z "$cp_internal" ] && [ -f /tmp/ci-deploy.log ]; then
            cp_internal="$(sed -n 's/^Agent registration URL: \(https\?:\/\/[^[:space:]]\+\).*/\1/p' /tmp/ci-deploy.log | tail -n1 | xargs || true)"
          fi
          if [ -z "$cp_internal" ] && [ -f /tmp/ci-deploy.log ]; then
            cp_internal="$(sed -n 's/^Control plane URL: \(https\?:\/\/[^[:space:]]\+\).*/\1/p' /tmp/ci-deploy.log | tail -n1 | xargs || true)"
          fi
          if [ -z "$cp_public" ] && [ -f /tmp/ci-deploy.log ]; then
            cp_public="$(sed -n 's/^Public URL is up: \(https\?:\/\/[^[:space:]]\+\).*/\1/p' /tmp/ci-deploy.log | tail -n1 | xargs || true)"
          fi

          if [ -z "$cp_url" ]; then
            if [ -n "$cp_public" ]; then
              cp_url="$cp_public"
            else
              cp_url="$cp_internal"
            fi
          fi

          if [ -z "$cp_internal" ] || [ -z "$cp_url" ]; then
            echo "::error::Could not resolve control-plane URLs from deploy step output or deploy logs."
            if [ -f /tmp/ci-deploy.log ]; then
              tail -n 120 /tmp/ci-deploy.log || true
            fi
            exit 1
          fi

          {
            echo "cp_internal_url=$cp_internal"
            echo "cp_public_url=$cp_public"
            echo "cp_url=$cp_url"
          } >> "$GITHUB_OUTPUT"

      - name: Mint bootstrap admin token
        id: admin_token
        shell: bash
        env:
          CP_INTERNAL_URL: ${{ steps.cp_urls.outputs.cp_internal_url }}
        run: |
          set -euo pipefail
          if [ -z "${CP_INTERNAL_URL:-}" ]; then
            echo "::error::Missing CP internal URL; cannot mint bootstrap admin token."
            exit 1
          fi
          if [ -z "${ADMIN_PASSWORD:-}" ]; then
            echo "::error::Missing ADMIN_PASSWORD; cannot mint bootstrap admin token."
            exit 1
          fi
          payload="$(jq -cn --arg p "${ADMIN_PASSWORD}" '{password: $p}')"
          token="$(curl -sS -X POST "${CP_INTERNAL_URL}/admin/login" -H 'Content-Type: application/json' -d "$payload" | jq -r '.token // empty' 2>/dev/null || true)"
          if [ -z "$token" ]; then
            echo "::error::Failed to mint bootstrap admin token via ${CP_INTERNAL_URL}/admin/login"
            exit 1
          fi
          echo "::add-mask::$token"
          echo "cp_admin_token=$token" >> "$GITHUB_OUTPUT"
          echo "Minted bootstrap admin token."
