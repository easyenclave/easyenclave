# Deploy Examples
#
# Deploys example apps after CI passes, using the shared control plane.

name: Deploy Examples

on:
  workflow_run:
    workflows: [CI]
    types: [completed]
    branches: [main]
  workflow_dispatch: {}

concurrency:
  # This workflow now bootstraps the shared control plane; do not overlap with any other CP-mutating run.
  group: easyenclave-shared-control-plane
  cancel-in-progress: false

env:
  CP_URL: https://app.easyenclave.com
  CP_EXPECTED_BOOT_ID: deploy-examples-${{ github.run_id }}-${{ github.run_attempt }}
  CP_EXPECTED_GIT_SHA: ${{ github.event.workflow_run.head_sha || github.sha }}

jobs:
  bootstrap-control-plane:
    name: Bootstrap Control Plane (for examples)
    runs-on: [self-hosted, tdx]
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'
    permissions:
      contents: read
    env:
      # Coordination metadata (exposed by /health).
      EASYENCLAVE_BOOT_ID: deploy-examples-${{ github.run_id }}-${{ github.run_attempt }}
      EASYENCLAVE_GIT_SHA: ${{ github.event.workflow_run.head_sha || github.sha }}

      # Infra + trust.
      INTEL_API_KEY: ${{ secrets.INTEL_API_KEY }}
      ITA_API_KEY: ${{ secrets.INTEL_API_KEY }}

      # Cloudflare (public endpoint for https://app.easyenclave.com).
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}

      # GitHub OAuth (admin login + deployer identity).
      GITHUB_OAUTH_CLIENT_ID: ${{ secrets.EE_GITHUB_OAUTH_CLIENT_ID }}
      GITHUB_OAUTH_CLIENT_SECRET: ${{ secrets.EE_GITHUB_OAUTH_CLIENT_SECRET }}
      GITHUB_OAUTH_REDIRECT_URI: ${{ secrets.EE_GITHUB_OAUTH_REDIRECT_URI }}
      ADMIN_GITHUB_LOGINS: ${{ secrets.ADMIN_GITHUB_LOGINS }}

      # Stripe (optional billing).
      STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
      STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}

      # Admin password for bootstrap (used to attest the initial measurer).
      ADMIN_PASSWORD: ${{ secrets.CP_ADMIN_PASSWORD }}

      # Bootstrap sizes (keep minimal by default).
      CP_BOOTSTRAP_SIZES: tiny
      NUM_TINY_AGENTS: "1"
      NUM_STANDARD_AGENTS: "0"
      NUM_LLM_AGENTS: "0"

      # Use :latest so we can bootstrap without needing the exact SHA image.
      CONTROL_PLANE_IMAGE: ghcr.io/${{ github.repository }}/control-plane:latest
      MEASURER_IMAGE: ghcr.io/${{ github.repository }}/measuring-enclave:latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ env.CP_EXPECTED_GIT_SHA }}

      - name: Validate required secrets
        run: |
          set -euo pipefail
          for v in INTEL_API_KEY CLOUDFLARE_API_TOKEN CLOUDFLARE_ACCOUNT_ID CLOUDFLARE_ZONE_ID ADMIN_PASSWORD; do
            if [ -z "${!v:-}" ]; then
              echo "::error::Missing required secret/env: $v"
              exit 1
            fi
          done

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Derive ADMIN_PASSWORD_HASH (for control plane container)
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import os
          import bcrypt
          pw = os.environ.get("ADMIN_PASSWORD", "").encode()
          if not pw:
            raise SystemExit("ADMIN_PASSWORD missing")
          hashed = bcrypt.hashpw(pw, bcrypt.gensalt()).decode()
          with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as f:
            f.write("ADMIN_PASSWORD_HASH=" + hashed + "\n")
          PY

      - name: Cleanup leaked measurement VMs (best effort)
        run: |
          set -euo pipefail
          if command -v virsh >/dev/null 2>&1; then
            for d in $(virsh list --all --name | grep '^tdvirsh-trust_domain_verity-' || true); do
              [ -n "$d" ] || continue
              virsh destroy "$d" >/dev/null 2>&1 || true
              virsh undefine "$d" --nvram >/dev/null 2>&1 || virsh undefine "$d" >/dev/null 2>&1 || true
            done
          fi

      - name: Build and measure trusted values (tiny)
        id: measure
        env:
          MEASURE_SIZES: tiny
        run: ./scripts/ci-build-measure.sh

      - name: Deploy control plane + bootstrap agents/apps
        env:
          TRUSTED_AGENT_MRTDS: ${{ steps.measure.outputs.mrtds }}
          TRUSTED_AGENT_MRTDS_BY_SIZE: ${{ steps.measure.outputs.mrtds_by_size }}
          TRUSTED_AGENT_RTMRS: ${{ steps.measure.outputs.rtmrs }}
          TRUSTED_AGENT_RTMRS_BY_SIZE: ${{ steps.measure.outputs.rtmrs_by_size }}
        run: ./scripts/ci-deploy.sh

  test-unregistered-app-fails:
    name: Test - Unregistered app deploy fails
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Wait for control plane bootstrap (boot_id match)
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for $CP_URL/health boot_id=$CP_EXPECTED_BOOT_ID"
          deadline=$(( $(date +%s) + 900 ))
          while :; do
            body="$(curl -fsS "$CP_URL/health" 2>/dev/null || true)"
            bid="$(echo "${body:-}" | jq -r '.boot_id // empty' 2>/dev/null || true)"
            sha="$(echo "${body:-}" | jq -r '.git_sha // empty' 2>/dev/null || true)"
            if [ -n "${bid:-}" ] && [ "$bid" = "$CP_EXPECTED_BOOT_ID" ]; then
              echo "Control plane ready: boot_id=$bid git_sha=${sha:-unknown}"
              break
            fi
            now="$(date +%s)"
            if [ "$now" -ge "$deadline" ]; then
              echo "::error::Timed out waiting for control plane boot_id=$CP_EXPECTED_BOOT_ID"
              echo "Last /health:"
              echo "${body:-<empty>}"
              exit 1
            fi
            sleep 5
          done

      - name: Deploy unregistered app (should fail)
        id: deploy
        uses: ./.github/actions/deploy
        continue-on-error: true
        with:
          app_name: unregistered-test-app
          compose_file: examples/hello-tdx/docker-compose.yml
          service_name: hello-tdx
          health_endpoint: /

      - name: Verify deploy failed
        run: |
          if [ "${{ steps.deploy.outcome }}" != "failure" ]; then
            echo "::error::Expected deploy to fail for unregistered app, but it succeeded"
            exit 1
          fi
          echo "Deploy correctly failed for unregistered app"

  register-hello-tdx:
    name: Register Hello TDX
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Wait for control plane bootstrap (boot_id match)
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for $CP_URL/health boot_id=$CP_EXPECTED_BOOT_ID"
          deadline=$(( $(date +%s) + 900 ))
          while :; do
            body="$(curl -fsS "$CP_URL/health" 2>/dev/null || true)"
            bid="$(echo "${body:-}" | jq -r '.boot_id // empty' 2>/dev/null || true)"
            sha="$(echo "${body:-}" | jq -r '.git_sha // empty' 2>/dev/null || true)"
            if [ -n "${bid:-}" ] && [ "$bid" = "$CP_EXPECTED_BOOT_ID" ]; then
              echo "Control plane ready: boot_id=$bid git_sha=${sha:-unknown}"
              break
            fi
            now="$(date +%s)"
            if [ "$now" -ge "$deadline" ]; then
              echo "::error::Timed out waiting for control plane boot_id=$CP_EXPECTED_BOOT_ID"
              echo "Last /health:"
              echo "${body:-<empty>}"
              exit 1
            fi
            sleep 5
          done

      - name: Register app
        uses: ./.github/actions/register-app
        with:
          name: hello-tdx
          description: "Hello TDX - Example app demonstrating TDX attestation"

  deploy-hello-tdx-clouds:
    name: Deploy Hello TDX (default)
    runs-on: ubuntu-latest
    needs: register-hello-tdx
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Wait for control plane bootstrap (boot_id match)
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for $CP_URL/health boot_id=$CP_EXPECTED_BOOT_ID"
          deadline=$(( $(date +%s) + 900 ))
          while :; do
            body="$(curl -fsS "$CP_URL/health" 2>/dev/null || true)"
            bid="$(echo "${body:-}" | jq -r '.boot_id // empty' 2>/dev/null || true)"
            sha="$(echo "${body:-}" | jq -r '.git_sha // empty' 2>/dev/null || true)"
            if [ -n "${bid:-}" ] && [ "$bid" = "$CP_EXPECTED_BOOT_ID" ]; then
              echo "Control plane ready: boot_id=$bid git_sha=${sha:-unknown}"
              break
            fi
            now="$(date +%s)"
            if [ "$now" -ge "$deadline" ]; then
              echo "::error::Timed out waiting for control plane boot_id=$CP_EXPECTED_BOOT_ID"
              echo "Last /health:"
              echo "${body:-<empty>}"
              exit 1
            fi
            sleep 5
          done

      - name: Deploy to EasyEnclave
        uses: ./.github/actions/deploy-example
        with:
          app_name: hello-tdx
          compose_file: examples/hello-tdx/docker-compose.yml
          service_name: hello-tdx
          health_endpoint: /
          agent_admin_password: ${{ secrets.AGENT_ADMIN_PASSWORD }}
          github_owner: ${{ github.repository_owner }}
          node_size: tiny
          allowed_clouds: baremetal

  deploy-hello-tdx-gcp:
    name: Deploy Hello TDX (gcp)
    runs-on: ubuntu-latest
    needs: register-hello-tdx
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Wait for control plane bootstrap (boot_id match)
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for $CP_URL/health boot_id=$CP_EXPECTED_BOOT_ID"
          deadline=$(( $(date +%s) + 900 ))
          while :; do
            body="$(curl -fsS "$CP_URL/health" 2>/dev/null || true)"
            bid="$(echo "${body:-}" | jq -r '.boot_id // empty' 2>/dev/null || true)"
            sha="$(echo "${body:-}" | jq -r '.git_sha // empty' 2>/dev/null || true)"
            if [ -n "${bid:-}" ] && [ "$bid" = "$CP_EXPECTED_BOOT_ID" ]; then
              echo "Control plane ready: boot_id=$bid git_sha=${sha:-unknown}"
              break
            fi
            now="$(date +%s)"
            if [ "$now" -ge "$deadline" ]; then
              echo "::error::Timed out waiting for control plane boot_id=$CP_EXPECTED_BOOT_ID"
              echo "Last /health:"
              echo "${body:-<empty>}"
              exit 1
            fi
            sleep 5
          done

      - name: Deploy to EasyEnclave (GCP)
        uses: ./.github/actions/gcp-deploy-example
        with:
          app_name: hello-tdx
          compose_file: examples/hello-tdx/docker-compose.yml
          service_name: hello-tdx
          health_endpoint: /
          agent_admin_password: ${{ secrets.AGENT_ADMIN_PASSWORD }}
          github_owner: ${{ github.repository_owner }}
          node_size: tiny
          gcp_datacenter: ${{ vars.GCP_DATACENTER || 'gcp:us-central1-a' }}
          billing_account_id: ${{ secrets.CP_DEPLOYER_ACCOUNT_ID }}
          billing_api_key: ${{ secrets.CP_DEPLOYER_API_KEY }}
          billing_months: "1"
          intel_api_key: ${{ secrets.INTEL_API_KEY }}
          gcp_project_id: ${{ secrets.GCP_PROJECT_ID }}
          gcp_service_account_key: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
          gcp_zone: ${{ vars.GCP_ZONE || 'us-central1-a,us-central1-b,us-central1-c,us-central1-f,us-east4-a,us-west1-b' }}

  inventory-local-tdx:
    name: Inventory/Cleanup - Local TDX measurement VMs
    runs-on: [self-hosted, tdx]
    needs: [bootstrap-control-plane, deploy-hello-tdx-clouds, deploy-hello-tdx-gcp]
    if: always()
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Local VM inventory (before)
        shell: bash
        run: |
          set -euo pipefail
          echo "=== virsh list --all ==="
          virsh list --all || true
          echo ""
          echo "=== tdx_cli vm list ==="
          python3 infra/tdx_cli.py vm list || true
          echo ""
          echo "=== /var/tmp/tdvirsh disk usage ==="
          sudo du -sh /var/tmp/tdvirsh 2>/dev/null || du -sh /var/tmp/tdvirsh 2>/dev/null || true

      - name: Destroy leaked measurement domains (trust_domain_verity)
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v virsh >/dev/null 2>&1; then
            echo "::warning::virsh not found; skipping measurement domain cleanup"
            exit 0
          fi
          mapfile -t domains < <(virsh list --all --name | grep '^tdvirsh-trust_domain_verity-' || true)
          if [ "${#domains[@]}" -eq 0 ]; then
            echo "No leaked trust_domain_verity domains found."
            exit 0
          fi
          echo "Cleaning leaked measurement domains:"
          printf '  - %s\n' "${domains[@]}"
          for d in "${domains[@]}"; do
            virsh destroy "$d" >/dev/null 2>&1 || true
            virsh undefine "$d" --nvram >/dev/null 2>&1 || virsh undefine "$d" >/dev/null 2>&1 || true
          done

      - name: Local VM inventory (after)
        shell: bash
        run: |
          set -euo pipefail
          echo "=== virsh list --all ==="
          virsh list --all || true
          echo ""
          echo "=== tdx_cli vm list ==="
          python3 infra/tdx_cli.py vm list || true
