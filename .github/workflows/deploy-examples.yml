# Builtin Deploy Examples
#
# Deploys example apps after CI passes, using the shared control plane.

name: Builtin Deploy Examples

on:
  workflow_run:
    workflows: [CI]
    types: [completed]
    branches: [main]
  workflow_dispatch: {}

concurrency:
  # Keep one baremetal/default deploy-example run at a time; allow GCP workflow to run in parallel.
  group: easyenclave-deploy-examples-baremetal
  # Prefer the newest run; older deploy-example runs can get stuck on slow capacity.
  cancel-in-progress: true

env:
  CP_URL: https://app.easyenclave.com
  CP_EXPECTED_GIT_SHA: ${{ github.event.workflow_run.head_sha || github.sha }}

jobs:
  test-unregistered-app-fails:
    name: Test - Unregistered app deploy fails
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Wait for control plane bootstrap (git_sha match)
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for $CP_URL/health git_sha=$CP_EXPECTED_GIT_SHA"
          deadline=$(( $(date +%s) + 900 ))
          while :; do
            body="$(curl -fsS "$CP_URL/health" 2>/dev/null || true)"
            sha="$(echo "${body:-}" | jq -r '.git_sha // empty' 2>/dev/null || true)"
            if [ -n "${sha:-}" ] && [ "$sha" = "$CP_EXPECTED_GIT_SHA" ]; then
              echo "Control plane ready: git_sha=$sha"
              break
            fi
            now="$(date +%s)"
            if [ "$now" -ge "$deadline" ]; then
              echo "::error::Timed out waiting for control plane git_sha=$CP_EXPECTED_GIT_SHA"
              echo "Last /health:"
              echo "${body:-<empty>}"
              exit 1
            fi
            sleep 5
          done

      - name: Deploy unregistered app (should fail)
        id: deploy
        uses: ./.github/actions/deploy
        continue-on-error: true
        with:
          app_name: unregistered-test-app
          compose_file: examples/hello-tdx/docker-compose.yml
          service_name: hello-tdx
          health_endpoint: /

      - name: Verify deploy failed
        run: |
          if [ "${{ steps.deploy.outcome }}" != "failure" ] && [ "${{ steps.deploy.conclusion }}" != "failure" ]; then
            echo "::error::Expected deploy to fail for unregistered app, but it succeeded"
            exit 1
          fi
          echo "Deploy correctly failed for unregistered app"

  register-hello-tdx:
    name: Register Hello TDX
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Wait for control plane bootstrap (git_sha match)
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for $CP_URL/health git_sha=$CP_EXPECTED_GIT_SHA"
          deadline=$(( $(date +%s) + 900 ))
          while :; do
            body="$(curl -fsS "$CP_URL/health" 2>/dev/null || true)"
            sha="$(echo "${body:-}" | jq -r '.git_sha // empty' 2>/dev/null || true)"
            if [ -n "${sha:-}" ] && [ "$sha" = "$CP_EXPECTED_GIT_SHA" ]; then
              echo "Control plane ready: git_sha=$sha"
              break
            fi
            now="$(date +%s)"
            if [ "$now" -ge "$deadline" ]; then
              echo "::error::Timed out waiting for control plane git_sha=$CP_EXPECTED_GIT_SHA"
              echo "Last /health:"
              echo "${body:-<empty>}"
              exit 1
            fi
            sleep 5
          done

      - name: Register app
        uses: ./.github/actions/register-app
        with:
          name: hello-tdx
          description: "Hello TDX - Example app demonstrating TDX attestation"

  ensure-baremetal-tiny-capacity:
    name: Ensure baremetal tiny agent (capacity)
    runs-on: [self-hosted, tdx]
    needs: register-hello-tdx
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'
    permissions:
      contents: read
    env:
      # Used to boot a tiny agent VM that can self-mint Intel Trust Authority tokens for registration.
      ITA_API_KEY: ${{ secrets.INTEL_API_KEY }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Build verity artifacts (required for tdx_cli vm new)
        shell: bash
        run: |
          set -euo pipefail
          cd infra/image
          nix develop --command make build

      - name: Wait for control plane bootstrap (git_sha match)
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for $CP_URL/health git_sha=$CP_EXPECTED_GIT_SHA"
          deadline=$(( $(date +%s) + 900 ))
          while :; do
            body="$(curl -fsS "$CP_URL/health" 2>/dev/null || true)"
            sha="$(echo "${body:-}" | jq -r '.git_sha // empty' 2>/dev/null || true)"
            if [ -n "${sha:-}" ] && [ "$sha" = "$CP_EXPECTED_GIT_SHA" ]; then
              echo "Control plane ready: git_sha=$sha"
              break
            fi
            now="$(date +%s)"
            if [ "$now" -ge "$deadline" ]; then
              echo "::error::Timed out waiting for control plane git_sha=$CP_EXPECTED_GIT_SHA"
              echo "Last /health:"
              echo "${body:-<empty>}"
              exit 1
            fi
            sleep 5
          done

      - name: Ensure deployable baremetal tiny agent exists
        shell: bash
        run: |
          set -euo pipefail
          ita_key="${ITA_API_KEY:-${INTEL_API_KEY:-}}"
          if [ -z "${ita_key:-}" ]; then
            echo "::error::Missing ITA_API_KEY (Intel Trust Authority API key); cannot boot agents."
            exit 1
          fi

          count_deployable() {
            curl -sSf "${CP_URL}/api/v1/agents" | jq -r '
              [.agents[]
                | select(.verified == true)
                | select((.health_status // "" | ascii_downcase) == "healthy")
                | select(((.status // "" | ascii_downcase) == "undeployed" or (.status // "" | ascii_downcase) == "deployed"))
                | select((.node_size // "" | ascii_downcase) == "tiny")
                | select((.datacenter // "" | ascii_downcase) == "baremetal:github-runner")
                | select(((.deployed_app // "") | startswith("measuring-enclave")) | not)
              ] | length'
          }

          count="$(count_deployable || echo 0)"
          echo "Deployable baremetal tiny candidates: $count"
          if [ "${count:-0}" -ge 1 ]; then
            exit 0
          fi

          echo "Booting a new baremetal tiny agent VM..."
          python3 infra/tdx_cli.py vm new \
            --size tiny \
            --cloud-provider baremetal \
            --availability-zone github-runner \
            --easyenclave-url "${CP_URL}" \
            --intel-api-key "${ita_key}" \
            --wait \
            >/tmp/new_tiny_vm.json
          cat /tmp/new_tiny_vm.json || true

          for i in {1..60}; do
            count="$(count_deployable || echo 0)"
            if [ "${count:-0}" -ge 1 ]; then
              echo "Deployable baremetal tiny capacity is now available: $count"
              exit 0
            fi
            if [ $((i % 6)) -eq 0 ]; then
              echo "Still waiting for deployable baremetal tiny capacity... ($i/60)"
              curl -sSf "${CP_URL}/api/v1/agents" | jq -r '
                [.agents[] | select((.node_size // "" | ascii_downcase) == "tiny")
                  | {agent_id, status, health_status, verified, datacenter, deployed_app, vm_name, verification_error}]'
            fi
            sleep 5
          done

          echo "::error::Timed out waiting for deployable baremetal tiny capacity."
          curl -sSf "${CP_URL}/api/v1/agents" | jq -r '
            [.agents[] | select((.node_size // "" | ascii_downcase) == "tiny")
              | {agent_id, status, health_status, verified, datacenter, deployed_app, vm_name}]'
          exit 1

  deploy-hello-tdx-clouds:
    name: Deploy Hello TDX (default)
    runs-on: ubuntu-latest
    needs: [register-hello-tdx, ensure-baremetal-tiny-capacity]
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Wait for control plane bootstrap (git_sha match)
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for $CP_URL/health git_sha=$CP_EXPECTED_GIT_SHA"
          deadline=$(( $(date +%s) + 900 ))
          while :; do
            body="$(curl -fsS "$CP_URL/health" 2>/dev/null || true)"
            sha="$(echo "${body:-}" | jq -r '.git_sha // empty' 2>/dev/null || true)"
            if [ -n "${sha:-}" ] && [ "$sha" = "$CP_EXPECTED_GIT_SHA" ]; then
              echo "Control plane ready: git_sha=$sha"
              break
            fi
            now="$(date +%s)"
            if [ "$now" -ge "$deadline" ]; then
              echo "::error::Timed out waiting for control plane git_sha=$CP_EXPECTED_GIT_SHA"
              echo "Last /health:"
              echo "${body:-<empty>}"
              exit 1
            fi
            sleep 5
          done

      - name: Deploy to EasyEnclave
        uses: ./.github/actions/deploy-example
        with:
          app_name: hello-tdx
          compose_file: examples/hello-tdx/docker-compose.yml
          service_name: hello-tdx
          health_endpoint: /
          agent_admin_password: ${{ secrets.AGENT_ADMIN_PASSWORD }}
          github_owner: ${{ github.repository_owner }}
          node_size: tiny
          allowed_clouds: baremetal

  deploy-private-llm-baremetal:
    name: Deploy Private LLM (baremetal)
    runs-on: [self-hosted, tdx]
    needs: [deploy-hello-tdx-clouds]
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'
    permissions:
      contents: read
    env:
      CP_ADMIN_TOKEN: ${{ secrets.CP_ADMIN_TOKEN }}
      CP_ADMIN_PASSWORD: ${{ secrets.CP_ADMIN_PASSWORD }}
      AGENT_ADMIN_PASSWORD: ${{ secrets.AGENT_ADMIN_PASSWORD }}
      # Used to boot LLM agent VMs that can self-mint Intel Trust Authority tokens for registration.
      ITA_API_KEY: ${{ secrets.INTEL_API_KEY }}
      TARGET_DATACENTER: baremetal:github-runner
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Build verity artifacts (required for tdx_cli vm new)
        shell: bash
        run: |
          set -euo pipefail
          cd infra/image
          nix develop --command make build

      - name: Wait for control plane bootstrap (git_sha match)
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for $CP_URL/health git_sha=$CP_EXPECTED_GIT_SHA"
          deadline=$(( $(date +%s) + 900 ))
          while :; do
            body="$(curl -fsS "$CP_URL/health" 2>/dev/null || true)"
            sha="$(echo "${body:-}" | jq -r '.git_sha // empty' 2>/dev/null || true)"
            if [ -n "${sha:-}" ] && [ "$sha" = "$CP_EXPECTED_GIT_SHA" ]; then
              echo "Control plane ready: git_sha=$sha"
              break
            fi
            now="$(date +%s)"
            if [ "$now" -ge "$deadline" ]; then
              echo "::error::Timed out waiting for control plane git_sha=$CP_EXPECTED_GIT_SHA"
              echo "Last /health:"
              echo "${body:-<empty>}"
              exit 1
            fi
            sleep 5
          done

      - name: Validate required secrets for baremetal LLM deploy
        shell: bash
        env:
          AGENT_ADMIN_PASSWORD: ${{ secrets.AGENT_ADMIN_PASSWORD }}
          CP_ADMIN_TOKEN: ${{ secrets.CP_ADMIN_TOKEN }}
          CP_ADMIN_PASSWORD: ${{ secrets.CP_ADMIN_PASSWORD }}
        run: |
          set -euo pipefail
          if [ -z "${AGENT_ADMIN_PASSWORD:-}" ]; then
            echo "::error::Missing secret: AGENT_ADMIN_PASSWORD"
            exit 1
          fi
          # CP_ADMIN_TOKEN/CP_ADMIN_PASSWORD are no longer required for measurer bootstrap.

      - name: Cleanup stale CI LLM VMs (preflight, best effort)
        shell: bash
        env:
          CP_URL: ${{ env.CP_URL }}
          CP_ADMIN_PASSWORD: ${{ env.CP_ADMIN_PASSWORD }}
        run: |
          set -euo pipefail
          bash ./scripts/cleanup_ci_llm_vms.sh || true

      - name: Check measuring-enclave-llm health
        shell: bash
        run: |
          echo "Control plane measures app versions directly; measuring-enclave is no longer required."

      - name: Measure + trust llm baseline (bootstrap)
        id: llm_baseline
        shell: bash
        run: |
          set -euo pipefail

          admin_token="${CP_ADMIN_TOKEN:-}"
          if [ -z "${admin_token:-}" ]; then
            if [ -z "${CP_ADMIN_PASSWORD:-}" ]; then
              echo "::error::Missing CP_ADMIN_TOKEN/CP_ADMIN_PASSWORD; cannot trust LLM baseline for bootstrap."
              exit 1
            fi
            resp="$(curl -sSf "${CP_URL}/admin/login" \
              -H "Content-Type: application/json" \
              -d "{\"password\": \"${CP_ADMIN_PASSWORD}\"}")"
            admin_token="$(echo "$resp" | jq -r '.token // empty')"
          fi
          if [ -z "${admin_token:-}" ] || [ "${admin_token:-}" = "null" ]; then
            echo "::error::Admin login failed; cannot trust LLM baseline."
            exit 1
          fi

          # Measure locally on the TDX runner so the first LLM agent can verify.
          measurements="$(python3 infra/tdx_cli.py vm measure --size llm --json)"
          mrtd="$(echo "$measurements" | jq -r '.mrtd // empty')"
          rtmrs="$(echo "$measurements" | jq -c '{rtmr0,rtmr1,rtmr2,rtmr3}')"
          if [ -z "${mrtd:-}" ] || [ "${mrtd:-}" = "null" ]; then
            echo "::error::Failed to measure llm baseline MRTD"
            echo "$measurements" | head -c 2000 || true
            exit 1
          fi

          # Trust this MRTD baseline at runtime (DB-backed trust list).
          curl -sSf -X POST "${CP_URL}/api/v1/admin/trusted-mrtds" \
            -H "Authorization: Bearer ${admin_token}" \
            -H "Content-Type: application/json" \
            -d "$(jq -cn \
              --arg mrtd "$mrtd" \
              --arg note "builtin-examples llm baseline (measured $(date -u +%Y-%m-%dT%H:%M:%SZ))" \
              '{mrtd:$mrtd,type:"agent",note:$note}')" \
            >/dev/null

          echo "mrtds_by_size=$(jq -cn --arg mrtd "$mrtd" '{llm:$mrtd}')" >> "$GITHUB_OUTPUT"
          echo "rtmrs_by_size=$(jq -cn --argjson rtmrs "$rtmrs" '{llm:$rtmrs}')" >> "$GITHUB_OUTPUT"
          echo "Using measured llm baseline MRTD: ${mrtd:0:16}..."

      - name: Ensure baremetal llm capacity for private-llm
        id: ensure_agents
        shell: bash
        run: |
          set -euo pipefail
          created=()
          max_boots=3
          boots=0
          ita_key="${ITA_API_KEY:-${INTEL_API_KEY:-}}"
          if [ -z "${ita_key:-}" ]; then
            echo "::error::Missing ITA_API_KEY (Intel Trust Authority API key); cannot boot LLM agents."
            exit 1
          fi

          count_non_measurer() {
            curl -sSf "${CP_URL}/api/v1/agents" | jq -r --arg dc "${TARGET_DATACENTER}" '
              [.agents[]
                | select(.verified == true)
                | select((.health_status // "" | ascii_downcase) == "healthy")
                | select(((.status // "" | ascii_downcase) == "undeployed" or (.status // "" | ascii_downcase) == "deployed"))
                | select((.node_size // "" | ascii_downcase) == "llm")
                | select((.datacenter // "" | ascii_downcase) == ($dc | ascii_downcase))
                | select(((.deployed_app // "") | startswith("measuring-enclave")) | not)
              ] | length'
          }

          non_measurer="$(count_non_measurer || echo 0)"
          required_non_measurer=1
          echo "Baremetal llm non-measurer candidates: $non_measurer (required: $required_non_measurer)"

          while [ "${non_measurer:-0}" -lt "${required_non_measurer}" ]; do
            boots=$((boots + 1))
            if [ "$boots" -gt "$max_boots" ]; then
              echo "::error::Exceeded max LLM boot attempts ($max_boots) while waiting for verified capacity."
              curl -sSf "${CP_URL}/api/v1/agents" | jq -r '
                [.agents[] | select((.node_size // "" | ascii_downcase) == "llm")
                  | {agent_id, status, health_status, verified, datacenter, deployed_app, vm_name}]'
              exit 1
            fi
            echo "Booting a new baremetal llm agent VM..."
            vm_json="$(python3 infra/tdx_cli.py vm new --size llm --cloud-provider baremetal --availability-zone github-runner --easyenclave-url "${CP_URL}" --wait --intel-api-key "${ita_key}")"
            name="$(echo "$vm_json" | jq -r '.name // empty')"
            if [ -n "$name" ]; then
              created+=("$name")
            fi

            # Give the agent time to register and pass verification.
            for i in {1..60}; do
            non_measurer="$(count_non_measurer || echo 0)"
            if [ "${non_measurer:-0}" -ge "${required_non_measurer}" ]; then
              break
            fi
              if [ $((i % 6)) -eq 0 ]; then
                echo "Still waiting for verified+healthy llm capacity... ($i/60)"
                echo "  non-measurer=$non_measurer required=$required_non_measurer"
                curl -sSf "${CP_URL}/api/v1/agents" | jq -r --arg dc "${TARGET_DATACENTER}" '
                  [.agents[]
                    | select((.node_size // "" | ascii_downcase) == "llm")
                    | select((.datacenter // "" | ascii_downcase) == ($dc | ascii_downcase))
                    | {agent_id, status, health_status, verified, deployed_app, vm_name, verification_error}]'
              fi
              sleep 5
            done

            non_measurer="$(count_non_measurer || echo 0)"
            echo "Baremetal llm non-measurer candidates now: $non_measurer (required: $required_non_measurer)"
          done

          printf '%s\n' "${created[@]:-}" > /tmp/new_llm_vms.txt || true
          echo "created_vms=$(paste -sd, /tmp/new_llm_vms.txt 2>/dev/null || true)" >> "$GITHUB_OUTPUT"

      - name: Measurer bootstrap (skipped)
        shell: bash
        run: |
          echo "Skipped: control plane measures versions directly."

      - name: Verify deployable baremetal llm agent exists
        shell: bash
        run: |
          set -euo pipefail
          count="$(curl -sSf "${CP_URL}/api/v1/agents" | jq -r --arg dc "${TARGET_DATACENTER}" '
            [.agents[]
              | select(.verified == true)
              | select((.health_status // "" | ascii_downcase) == "healthy")
              | select(((.status // "" | ascii_downcase) == "undeployed" or (.status // "" | ascii_downcase) == "deployed"))
              | select((.node_size // "" | ascii_downcase) == "llm")
              | select((.datacenter // "" | ascii_downcase) == ($dc | ascii_downcase))
              | select(((.deployed_app // "") | startswith("measuring-enclave")) | not)
            ] | length
          ')"
          echo "Deployable baremetal llm candidates: $count"
          if [ "${count:-0}" -lt 1 ]; then
            echo "::error::No deployable baremetal llm agent available for private-llm"
            curl -sSf "${CP_URL}/api/v1/agents" | jq -r '
              [.agents[] | select((.node_size // "" | ascii_downcase) == "llm")
                | {agent_id, status, health_status, verified, datacenter, deployed_app, vm_name}]'
            exit 1
          fi

      - name: Ensure app exists (idempotent)
        uses: ./.github/actions/register-app
        with:
          name: private-llm
          description: "Private LLM - Ollama running in a TDX enclave"
          control_plane_url: ${{ env.CP_URL }}

      - name: Deploy private-llm (llm)
        id: deploy
        uses: ./.github/actions/deploy-example
        with:
          app_name: private-llm
          compose_file: examples/private-llm/docker-compose.yml
          service_name: private-llm
          health_endpoint: /
          control_plane_url: ${{ env.CP_URL }}
          agent_admin_password: ${{ env.AGENT_ADMIN_PASSWORD }}
          github_owner: ${{ github.repository_owner }}
          node_size: llm
          allowed_clouds: baremetal
          allowed_datacenters: baremetal:github-runner

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install SDK and OpenAI client
        shell: bash
        run: pip install ./sdk/ openai

      - name: Smoke test private-llm (OpenAI-compatible)
        shell: bash
        env:
          SERVICE_URL: ${{ steps.deploy.outputs.service_url }}
          EASYENCLAVE_URL: ${{ env.CP_URL }}
        run: python3 examples/private-llm/test.py

      - name: Cleanup stale CI LLM VMs (post, best effort)
        if: always()
        shell: bash
        env:
          CP_URL: ${{ env.CP_URL }}
          CP_ADMIN_PASSWORD: ${{ env.CP_ADMIN_PASSWORD }}
        run: |
          set -euo pipefail
          bash ./scripts/cleanup_ci_llm_vms.sh || true

  inventory-local-tdx:
    name: Inventory/Cleanup - Local TDX measurement VMs
    runs-on: [self-hosted, tdx]
    needs: [deploy-hello-tdx-clouds, deploy-private-llm-baremetal]
    if: always()
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Local VM inventory (before)
        shell: bash
        run: |
          set -euo pipefail
          echo "=== virsh list --all ==="
          virsh list --all || true
          echo ""
          echo "=== tdx_cli vm list ==="
          python3 infra/tdx_cli.py vm list || true
          echo ""
          echo "=== /var/tmp/tdvirsh disk usage ==="
          sudo du -sh /var/tmp/tdvirsh 2>/dev/null || du -sh /var/tmp/tdvirsh 2>/dev/null || true

      - name: Destroy leaked measurement domains (trust_domain_verity)
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v virsh >/dev/null 2>&1; then
            echo "::warning::virsh not found; skipping measurement domain cleanup"
            exit 0
          fi
          mapfile -t domains < <(virsh list --all --name | grep '^tdvirsh-trust_domain_verity-' || true)
          if [ "${#domains[@]}" -eq 0 ]; then
            echo "No leaked trust_domain_verity domains found."
            exit 0
          fi
          echo "Cleaning leaked measurement domains:"
          printf '  - %s\n' "${domains[@]}"
          for d in "${domains[@]}"; do
            virsh destroy "$d" >/dev/null 2>&1 || true
            virsh undefine "$d" --nvram >/dev/null 2>&1 || virsh undefine "$d" >/dev/null 2>&1 || true
          done

      - name: Local VM inventory (after)
        shell: bash
        run: |
          set -euo pipefail
          echo "=== virsh list --all ==="
          virsh list --all || true
          echo ""
          echo "=== tdx_cli vm list ==="
          python3 infra/tdx_cli.py vm list || true
