# Builtin Deploy Examples (GCP)
#
# Canonical GCP example workflow:
# - hello-tdx on tiny
# - private-llm on llm (OpenAI-compatible smoke test, production only)

name: Builtin Deploy Examples (GCP)

on:
  workflow_call:
    inputs:
      cp_url:
        required: false
        type: string
        default: "https://app.easyenclave.com"
      cp_expected_git_sha:
        required: false
        type: string
        default: ""
      cp_expected_boot_id:
        required: false
        type: string
        default: ""
      cp_admin_token:
        required: false
        type: string
        default: ""
      billing_account_id:
        required: false
        type: string
        default: ""
      billing_api_key:
        required: false
        type: string
        default: ""
      source_ref:
        required: false
        type: string
        default: ""
      hello_tdx_image:
        required: false
        type: string
        default: ""
      private_llm_ollama_image:
        required: false
        type: string
        default: ""
      private_llm_model_loader_image:
        required: false
        type: string
        default: ""
      easyenclave_env:
        required: false
        type: string
        default: "staging"
  workflow_dispatch:
    inputs:
      cp_url:
        description: "Control plane URL"
        required: false
        default: "https://app.easyenclave.com"
      cp_expected_git_sha:
        description: "Expected control-plane git SHA from /health (optional)"
        required: false
        default: ""
      cp_expected_boot_id:
        description: "Expected control-plane boot_id from /health (optional)"
        required: false
        default: ""
      cp_admin_token:
        description: "Optional admin bearer token for trust bootstrap/teardown"
        required: false
        default: ""
      billing_account_id:
        description: "Billing deployer account id for this control plane"
        required: false
        default: ""
      billing_api_key:
        description: "Billing deployer API key for this control plane"
        required: false
        default: ""
      source_ref:
        description: "Git ref to checkout"
        required: false
        default: ""
      hello_tdx_image:
        description: "Optional hello-tdx image override (digest ref)"
        required: false
        default: ""
      private_llm_ollama_image:
        description: "Optional private-llm ollama image override (digest ref)"
        required: false
        default: ""
      private_llm_model_loader_image:
        description: "Optional private-llm model-loader image override (digest ref)"
        required: false
        default: ""
      easyenclave_env:
        description: "Environment profile (staging or production)"
        required: false
        default: "staging"

concurrency:
  # Keep one GCP deploy-example run at a time; allow baremetal/default workflow to run in parallel.
  group: easyenclave-deploy-examples-gcp-${{ github.run_id }}
  # Prefer the newest run; older deploy-example runs can get stuck on slow capacity.
  cancel-in-progress: true

env:
  CP_URL: ${{ inputs.cp_url || github.event.inputs.cp_url || 'https://app.easyenclave.com' }}
  CP_EXPECTED_GIT_SHA: ${{ inputs.cp_expected_git_sha || github.event.inputs.cp_expected_git_sha || '' }}
  CP_EXPECTED_BOOT_ID: ${{ inputs.cp_expected_boot_id || github.event.inputs.cp_expected_boot_id || '' }}
  CP_ADMIN_TOKEN: ${{ inputs.cp_admin_token || github.event.inputs.cp_admin_token || '' }}
  BILLING_ACCOUNT_ID: ${{ inputs.billing_account_id || github.event.inputs.billing_account_id || secrets.CP_DEPLOYER_ACCOUNT_ID || '' }}
  BILLING_API_KEY: ${{ inputs.billing_api_key || github.event.inputs.billing_api_key || secrets.CP_DEPLOYER_API_KEY || '' }}
  HELLO_TDX_IMAGE: ${{ inputs.hello_tdx_image || github.event.inputs.hello_tdx_image || '' }}
  PRIVATE_LLM_OLLAMA_IMAGE: ${{ inputs.private_llm_ollama_image || github.event.inputs.private_llm_ollama_image || '' }}
  PRIVATE_LLM_MODEL_LOADER_IMAGE: ${{ inputs.private_llm_model_loader_image || github.event.inputs.private_llm_model_loader_image || '' }}
  EASYENCLAVE_ENV: ${{ inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging' }}
  GCP_PROJECT_ID: ${{ ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') == 'production' && secrets.PRODUCTION_GCP_PROJECT_ID) || ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') != 'production' && (secrets.STAGING_GCP_PROJECT_ID || 'eestaging')) }}
  GCP_SERVICE_ACCOUNT_KEY: ${{ ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') == 'production' && secrets.PRODUCTION_GCP_SERVICE_ACCOUNT_KEY) || ((inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') != 'production' && secrets.STAGING_GCP_SERVICE_ACCOUNT_KEY) }}

jobs:
  deploy-hello-tdx-gcp:
    name: Deploy Hello TDX (gcp)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.source_ref || github.event.inputs.source_ref || github.sha }}

      - name: Prepare hello-tdx compose (optional release image override)
        id: hello_compose
        shell: bash
        run: |
          set -euo pipefail
          src="examples/hello-tdx/docker-compose.yml"
          out="${RUNNER_TEMP}/hello-tdx.compose.yml"
          cp "$src" "$out"
          if [ -n "${HELLO_TDX_IMAGE:-}" ]; then
            if ! grep -qE 'image:[[:space:]]*hashicorp/http-echo(@sha256:[0-9a-f]{64}|:latest)' "$out"; then
              echo "::error::Expected hello-tdx image line not found in $src"
              exit 1
            fi
            escaped="$(printf '%s' "${HELLO_TDX_IMAGE}" | sed -e 's/[&|]/\\&/g')"
            sed -i -E "s|image:[[:space:]]*hashicorp/http-echo(@sha256:[0-9a-f]{64}|:latest)|image: ${escaped}|g" "$out"
          fi
          echo "compose_file=$out" >> "$GITHUB_OUTPUT"

      - name: Wait for control plane bootstrap (identity match)
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for $CP_URL/health git_sha=${CP_EXPECTED_GIT_SHA:-<any>} boot_id=${CP_EXPECTED_BOOT_ID:-<any>}"
          deadline=$(( $(date +%s) + 900 ))
          while :; do
            body="$(curl -fsS "$CP_URL/health" 2>/dev/null || true)"
            sha="$(echo "${body:-}" | jq -r '.git_sha // empty' 2>/dev/null || true)"
            boot_id="$(echo "${body:-}" | jq -r '.boot_id // empty' 2>/dev/null || true)"

            ready=1
            if [ -n "${CP_EXPECTED_GIT_SHA:-}" ] && [ "${sha:-}" != "${CP_EXPECTED_GIT_SHA}" ]; then
              ready=0
            fi
            if [ -n "${CP_EXPECTED_BOOT_ID:-}" ] && [ "${boot_id:-}" != "${CP_EXPECTED_BOOT_ID}" ]; then
              ready=0
            fi

            if [ -n "${body:-}" ] && [ "$ready" -eq 1 ]; then
              echo "Control plane ready: git_sha=${sha:-unknown} boot_id=${boot_id:-unknown}"
              break
            fi
            now="$(date +%s)"
            if [ "$now" -ge "$deadline" ]; then
              echo "::error::Timed out waiting for control plane identity match."
              echo "::error::Expected git_sha='${CP_EXPECTED_GIT_SHA:-<any>}' boot_id='${CP_EXPECTED_BOOT_ID:-<any>}'"
              echo "::error::Last seen git_sha='${sha:-<none>}' boot_id='${boot_id:-<none>}'"
              echo "Last /health:"
              echo "${body:-<empty>}"
              exit 1
            fi
            sleep 5
          done

      - name: Validate required secrets for GCP deploy
        id: cfg_hello
        shell: bash
        env:
          AGENT_ADMIN_PASSWORD: ${{ secrets.AGENT_ADMIN_PASSWORD }}
          CP_ADMIN_PASSWORD: ${{ secrets.CP_ADMIN_PASSWORD }}
        run: |
          set -euo pipefail
          missing=0
          for v in AGENT_ADMIN_PASSWORD CP_ADMIN_PASSWORD; do
            if [ -z "${!v:-}" ]; then
              echo "::warning::Missing secret: $v"
              missing=1
            fi
          done
          if [ "$missing" -ne 0 ]; then
            echo "configured=false" >> "$GITHUB_OUTPUT"
            echo "::notice::GCP hello deploy is not configured; skipping job actions."
            exit 0
          fi
          echo "configured=true" >> "$GITHUB_OUTPUT"

      - name: Resolve billing credentials for this control plane (hello)
        if: steps.cfg_hello.outputs.configured == 'true'
        id: billing_hello
        shell: bash
        env:
          CP_ADMIN_TOKEN: ${{ env.CP_ADMIN_TOKEN || secrets.CP_ADMIN_TOKEN }}
          CP_ADMIN_PASSWORD: ${{ secrets.CP_ADMIN_PASSWORD }}
        run: |
          set -euo pipefail
          env_name="$(echo "${EASYENCLAVE_ENV:-staging}" | tr '[:upper:]' '[:lower:]' | xargs)"
          account_id="$(echo "${BILLING_ACCOUNT_ID:-}" | xargs)"
          api_key="$(echo "${BILLING_API_KEY:-}" | xargs)"

          probe_valid=false
          if [ -n "$account_id" ] && [ -n "$api_key" ]; then
            probe_code="$(curl -sS -o /tmp/hello-billing-probe.json -w "%{http_code}" \
              -H "Authorization: Bearer ${api_key}" \
              -H "Accept: application/json" \
              "$CP_URL/api/v1/accounts/${account_id}" || echo 000)"
            if [ "$probe_code" -lt 400 ]; then
              probe_valid=true
            else
              detail="$(jq -r '.detail // empty' /tmp/hello-billing-probe.json 2>/dev/null || true)"
              echo "::warning::Provided billing credentials are invalid for this control plane (HTTP $probe_code): ${detail:-$(cat /tmp/hello-billing-probe.json 2>/dev/null || true)}"
              echo "::warning::Creating a fresh run-scoped deployer account for ${env_name} hello deploy."
            fi
            rm -f /tmp/hello-billing-probe.json
          fi

          if [ "$probe_valid" != "true" ]; then
            token="$(echo "${CP_ADMIN_TOKEN:-}" | xargs)"
            if [ -z "$token" ] && [ -n "${CP_ADMIN_PASSWORD:-}" ]; then
              payload="$(jq -cn --arg p "${CP_ADMIN_PASSWORD}" '{password: $p}')"
              token="$(curl -sS -X POST "$CP_URL/admin/login" -H 'Content-Type: application/json' -d "$payload" | jq -r '.token // empty' 2>/dev/null || true)"
            fi
            if [ -z "$token" ]; then
              echo "::error::Could not mint admin token for billing account creation."
              exit 1
            fi

            sha12="$(echo "${CP_EXPECTED_GIT_SHA:-${GITHUB_SHA:-}}" | cut -c1-12)"
            account_name="gcp-hello-${env_name}-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${sha12}"
            account_name="$(echo "$account_name" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9-]+/-/g; s/^-+//; s/-+$//; s/-{2,}/-/g')"
            account_name="${account_name:0:64}"
            req="$(jq -cn --arg name "$account_name" --arg desc "CI deployer account for ${env_name} hello deploy" '{name:$name, description:$desc, account_type:"deployer"}')"

            create_code="$(curl -sS -o /tmp/hello-billing-create.json -w "%{http_code}" \
              -X POST "$CP_URL/api/v1/accounts" \
              -H "Authorization: Bearer ${token}" \
              -H "Content-Type: application/json" \
              -H "Accept: application/json" \
              -d "$req" || echo 000)"
            if [ "$create_code" -ge 400 ]; then
              detail="$(jq -r '.detail // empty' /tmp/hello-billing-create.json 2>/dev/null || true)"
              echo "::error::Failed to create deployer account (HTTP $create_code): ${detail:-$(cat /tmp/hello-billing-create.json 2>/dev/null || true)}"
              exit 1
            fi
            account_id="$(jq -r '.account_id // empty' /tmp/hello-billing-create.json 2>/dev/null || true)"
            api_key="$(jq -r '.api_key // empty' /tmp/hello-billing-create.json 2>/dev/null || true)"
            rm -f /tmp/hello-billing-create.json
            if [ -z "$account_id" ] || [ -z "$api_key" ]; then
              echo "::error::Account create response missing account_id/api_key."
              exit 1
            fi
          fi

          echo "::add-mask::$api_key"
          echo "billing_account_id=$account_id" >> "$GITHUB_OUTPUT"
          echo "billing_api_key=$api_key" >> "$GITHUB_OUTPUT"
          echo "Using billing account for hello deploy: ${account_id}"

      - name: Ensure app exists (idempotent)
        if: steps.cfg_hello.outputs.configured == 'true'
        uses: ./.github/actions/register-app
        with:
          name: hello-tdx
          description: "Hello TDX - Example app demonstrating TDX attestation"
          control_plane_url: ${{ env.CP_URL }}

      - name: Deploy to EasyEnclave (GCP)
        if: steps.cfg_hello.outputs.configured == 'true'
        id: deploy_hello
        uses: ./.github/actions/gcp-deploy-example
        with:
          app_name: hello-tdx
          compose_file: ${{ steps.hello_compose.outputs.compose_file }}
          service_name: hello-tdx
          health_endpoint: /
          control_plane_url: ${{ env.CP_URL }}
          agent_admin_password: ${{ secrets.AGENT_ADMIN_PASSWORD }}
          github_owner: ${{ github.repository_owner }}
          node_size: tiny
          gcp_datacenter: ${{ vars.GCP_DATACENTER || 'gcp:us-central1-a' }}
          billing_account_id: ${{ steps.billing_hello.outputs.billing_account_id }}
          billing_api_key: ${{ steps.billing_hello.outputs.billing_api_key }}
          billing_months: "1"
          gcp_project_id: ${{ env.GCP_PROJECT_ID }}
          gcp_service_account_key: ${{ env.GCP_SERVICE_ACCOUNT_KEY }}
          gcp_zone: ${{ vars.GCP_ZONE || 'us-central1-a,us-central1-b,us-central1-c,us-central1-f,us-east4-a,us-west1-b' }}
          cp_admin_token: ${{ env.CP_ADMIN_TOKEN || secrets.CP_ADMIN_TOKEN }}
          cp_admin_password: ${{ secrets.CP_ADMIN_PASSWORD }}

      - name: Resolve admin token for hello teardown
        id: teardown_auth_hello
        if: always() && steps.cfg_hello.outputs.configured == 'true' && steps.deploy_hello.outcome == 'success'
        shell: bash
        env:
          CP_ADMIN_TOKEN: ${{ env.CP_ADMIN_TOKEN || secrets.CP_ADMIN_TOKEN }}
          CP_ADMIN_PASSWORD: ${{ secrets.CP_ADMIN_PASSWORD }}
        run: |
          set -euo pipefail
          token="$(echo "${CP_ADMIN_TOKEN:-}" | xargs)"
          if [ -z "$token" ] && [ -n "${CP_ADMIN_PASSWORD:-}" ]; then
            payload="$(jq -cn --arg p "${CP_ADMIN_PASSWORD}" '{password: $p}')"
            token="$(curl -sS -X POST "$CP_URL/admin/login" -H 'Content-Type: application/json' -d "$payload" | jq -r '.token // empty' 2>/dev/null || true)"
          fi
          if [ -z "$token" ]; then
            echo "::warning::Could not resolve admin token for hello-tdx teardown."
            exit 0
          fi
          echo "::add-mask::$token"
          echo "admin_token=$token" >> "$GITHUB_OUTPUT"
          echo "Resolved admin token for hello-tdx teardown."

      - name: Teardown hello-tdx GCP deployment
        if: always() && steps.cfg_hello.outputs.configured == 'true' && steps.deploy_hello.outcome == 'success'
        shell: bash
        env:
          ADMIN_TOKEN: ${{ steps.teardown_auth_hello.outputs.admin_token }}
          AGENT_ID: ${{ steps.deploy_hello.outputs.agent_id }}
        run: |
          set -euo pipefail
          if [ -z "${AGENT_ID:-}" ]; then
            echo "::warning::No hello-tdx agent_id output; skipping teardown."
            exit 0
          fi
          if [ -z "${ADMIN_TOKEN:-}" ]; then
            echo "::warning::Missing admin token; cannot teardown hello-tdx deployment."
            exit 0
          fi

          undeploy_code="$(curl -sS -o /tmp/hello-undeploy.json -w "%{http_code}" \
            -X POST "$CP_URL/api/v1/agents/${AGENT_ID}/undeploy" \
            -H "Authorization: Bearer ${ADMIN_TOKEN}" \
            -H 'Accept: application/json' || true)"
          if [ "$undeploy_code" -lt 400 ]; then
            echo "hello-tdx undeploy succeeded for agent ${AGENT_ID}."
          else
            echo "::warning::hello-tdx undeploy failed (HTTP $undeploy_code): $(cat /tmp/hello-undeploy.json)"
          fi

          cleanup_body="$(jq -cn --arg reason "ci:gcp-hello-post-test-teardown" '{dry_run:false, reason:$reason}')"
          cleanup_code="$(curl -sS -o /tmp/hello-cleanup.json -w "%{http_code}" \
            -X POST "$CP_URL/api/v1/admin/agents/${AGENT_ID}/cleanup" \
            -H "Authorization: Bearer ${ADMIN_TOKEN}" \
            -H 'Content-Type: application/json' \
            -d "$cleanup_body" || true)"
          if [ "$cleanup_code" -lt 400 ]; then
            echo "hello-tdx cleanup succeeded for agent ${AGENT_ID}."
          else
            echo "::warning::hello-tdx cleanup failed (HTTP $cleanup_code): $(cat /tmp/hello-cleanup.json)"
          fi

  deploy-private-llm-gcp:
    name: Deploy Private LLM (gcp)
    # Production quota is tight in some projects (SSD_TOTAL_GB). Run after hello
    # teardown to avoid parallel GCP capacity spikes.
    needs: [deploy-hello-tdx-gcp]
    if: ${{ (inputs.easyenclave_env || github.event.inputs.easyenclave_env || 'staging') == 'production' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.source_ref || github.event.inputs.source_ref || github.sha }}

      - name: Prepare private-llm compose (optional release image overrides)
        id: llm_compose
        shell: bash
        run: |
          set -euo pipefail
          src="examples/private-llm/docker-compose.yml"
          out="${RUNNER_TEMP}/private-llm.compose.yml"
          cp "$src" "$out"

          if [ -n "${PRIVATE_LLM_OLLAMA_IMAGE:-}" ]; then
            if ! grep -qE 'image:[[:space:]]*ollama/ollama(@sha256:[0-9a-f]{64}|:latest)' "$out"; then
              echo "::error::Expected private-llm ollama image line not found in $src"
              exit 1
            fi
            escaped="$(printf '%s' "${PRIVATE_LLM_OLLAMA_IMAGE}" | sed -e 's/[&|]/\\&/g')"
            sed -i -E "s|image:[[:space:]]*ollama/ollama(@sha256:[0-9a-f]{64}|:latest)|image: ${escaped}|g" "$out"
          fi

          if [ -n "${PRIVATE_LLM_MODEL_LOADER_IMAGE:-}" ]; then
            if ! grep -qE 'image:[[:space:]]*curlimages/curl(@sha256:[0-9a-f]{64}|:latest)' "$out"; then
              echo "::error::Expected private-llm model-loader image line not found in $src"
              exit 1
            fi
            escaped="$(printf '%s' "${PRIVATE_LLM_MODEL_LOADER_IMAGE}" | sed -e 's/[&|]/\\&/g')"
            sed -i -E "s|image:[[:space:]]*curlimages/curl(@sha256:[0-9a-f]{64}|:latest)|image: ${escaped}|g" "$out"
          fi

          echo "compose_file=$out" >> "$GITHUB_OUTPUT"

      - name: Wait for control plane bootstrap (identity match)
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for $CP_URL/health git_sha=${CP_EXPECTED_GIT_SHA:-<any>} boot_id=${CP_EXPECTED_BOOT_ID:-<any>}"
          deadline=$(( $(date +%s) + 900 ))
          while :; do
            body="$(curl -fsS "$CP_URL/health" 2>/dev/null || true)"
            sha="$(echo "${body:-}" | jq -r '.git_sha // empty' 2>/dev/null || true)"
            boot_id="$(echo "${body:-}" | jq -r '.boot_id // empty' 2>/dev/null || true)"

            ready=1
            if [ -n "${CP_EXPECTED_GIT_SHA:-}" ] && [ "${sha:-}" != "${CP_EXPECTED_GIT_SHA}" ]; then
              ready=0
            fi
            if [ -n "${CP_EXPECTED_BOOT_ID:-}" ] && [ "${boot_id:-}" != "${CP_EXPECTED_BOOT_ID}" ]; then
              ready=0
            fi

            if [ -n "${body:-}" ] && [ "$ready" -eq 1 ]; then
              echo "Control plane ready: git_sha=${sha:-unknown} boot_id=${boot_id:-unknown}"
              break
            fi
            now="$(date +%s)"
            if [ "$now" -ge "$deadline" ]; then
              echo "::error::Timed out waiting for control plane identity match."
              echo "::error::Expected git_sha='${CP_EXPECTED_GIT_SHA:-<any>}' boot_id='${CP_EXPECTED_BOOT_ID:-<any>}'"
              echo "::error::Last seen git_sha='${sha:-<none>}' boot_id='${boot_id:-<none>}'"
              echo "Last /health:"
              echo "${body:-<empty>}"
              exit 1
            fi
            sleep 5
          done

      - name: Validate required secrets for GCP LLM deploy
        id: cfg_llm
        shell: bash
        env:
          # Agent admin password (set on deployed nodes for local admin UI auth).
          AGENT_ADMIN_PASSWORD: ${{ secrets.AGENT_ADMIN_PASSWORD }}
          # Control-plane admin auth (used for trusted MRTD writes / cleanup APIs).
          CP_ADMIN_TOKEN: ${{ env.CP_ADMIN_TOKEN || secrets.CP_ADMIN_TOKEN }}
          CP_ADMIN_PASSWORD: ${{ secrets.CP_ADMIN_PASSWORD }}
        run: |
          set -euo pipefail
          missing=0
          for v in AGENT_ADMIN_PASSWORD CP_ADMIN_PASSWORD; do
            if [ -z "${!v:-}" ]; then
              echo "::warning::Missing secret: $v"
              missing=1
            fi
          done
          if [ "$missing" -ne 0 ]; then
            echo "configured=false" >> "$GITHUB_OUTPUT"
            echo "::notice::GCP private-llm deploy is not configured; skipping job actions."
            exit 0
          fi
          echo "configured=true" >> "$GITHUB_OUTPUT"

      - name: Resolve billing credentials for this control plane (llm)
        if: steps.cfg_llm.outputs.configured == 'true'
        id: billing_llm
        shell: bash
        env:
          CP_ADMIN_TOKEN: ${{ env.CP_ADMIN_TOKEN || secrets.CP_ADMIN_TOKEN }}
          CP_ADMIN_PASSWORD: ${{ secrets.CP_ADMIN_PASSWORD }}
        run: |
          set -euo pipefail
          env_name="$(echo "${EASYENCLAVE_ENV:-production}" | tr '[:upper:]' '[:lower:]' | xargs)"
          account_id="$(echo "${BILLING_ACCOUNT_ID:-}" | xargs)"
          api_key="$(echo "${BILLING_API_KEY:-}" | xargs)"

          probe_valid=false
          if [ -n "$account_id" ] && [ -n "$api_key" ]; then
            probe_code="$(curl -sS -o /tmp/llm-billing-probe.json -w "%{http_code}" \
              -H "Authorization: Bearer ${api_key}" \
              -H "Accept: application/json" \
              "$CP_URL/api/v1/accounts/${account_id}" || echo 000)"
            if [ "$probe_code" -lt 400 ]; then
              probe_valid=true
            else
              detail="$(jq -r '.detail // empty' /tmp/llm-billing-probe.json 2>/dev/null || true)"
              echo "::warning::Provided billing credentials are invalid for this control plane (HTTP $probe_code): ${detail:-$(cat /tmp/llm-billing-probe.json 2>/dev/null || true)}"
              echo "::warning::Creating a fresh run-scoped deployer account for ${env_name} llm deploy."
            fi
            rm -f /tmp/llm-billing-probe.json
          fi

          if [ "$probe_valid" != "true" ]; then
            token="$(echo "${CP_ADMIN_TOKEN:-}" | xargs)"
            if [ -z "$token" ] && [ -n "${CP_ADMIN_PASSWORD:-}" ]; then
              payload="$(jq -cn --arg p "${CP_ADMIN_PASSWORD}" '{password: $p}')"
              token="$(curl -sS -X POST "$CP_URL/admin/login" -H 'Content-Type: application/json' -d "$payload" | jq -r '.token // empty' 2>/dev/null || true)"
            fi
            if [ -z "$token" ]; then
              echo "::error::Missing billing credentials and unable to mint admin token for account creation."
              exit 1
            fi

            sha12="$(echo "${CP_EXPECTED_GIT_SHA:-${GITHUB_SHA:-}}" | cut -c1-12)"
            account_name="gcp-llm-${env_name}-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${sha12}"
            account_name="$(echo "$account_name" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9-]+/-/g; s/^-+//; s/-+$//; s/-{2,}/-/g')"
            account_name="${account_name:0:64}"
            req="$(jq -cn --arg name "$account_name" --arg desc "CI deployer account for ${env_name} llm deploy" '{name:$name, description:$desc, account_type:"deployer"}')"

            create_code="$(curl -sS -o /tmp/llm-billing-create.json -w "%{http_code}" \
              -X POST "$CP_URL/api/v1/accounts" \
              -H "Authorization: Bearer ${token}" \
              -H "Content-Type: application/json" \
              -H "Accept: application/json" \
              -d "$req" || echo 000)"
            if [ "$create_code" -ge 400 ]; then
              detail="$(jq -r '.detail // empty' /tmp/llm-billing-create.json 2>/dev/null || true)"
              echo "::error::Failed to create deployer account (HTTP $create_code): ${detail:-$(cat /tmp/llm-billing-create.json 2>/dev/null || true)}"
              exit 1
            fi
            account_id="$(jq -r '.account_id // empty' /tmp/llm-billing-create.json 2>/dev/null || true)"
            api_key="$(jq -r '.api_key // empty' /tmp/llm-billing-create.json 2>/dev/null || true)"
            rm -f /tmp/llm-billing-create.json
            if [ -z "$account_id" ] || [ -z "$api_key" ]; then
              echo "::error::Account create response missing account_id/api_key."
              exit 1
            fi
          fi

          echo "::add-mask::$api_key"
          echo "billing_account_id=$account_id" >> "$GITHUB_OUTPUT"
          echo "billing_api_key=$api_key" >> "$GITHUB_OUTPUT"
          echo "Using billing account for llm deploy: ${account_id}"

      - name: Resolve GCP datacenter target (llm)
        if: steps.cfg_llm.outputs.configured == 'true'
        id: target
        shell: bash
        run: |
          set -euo pipefail
          dc="$(echo "${{ vars.GCP_DATACENTER || '' }}" | tr '[:upper:]' '[:lower:]' | xargs)"
          if [ -z "$dc" ]; then
            dc="gcp:us-central1-a"
          fi
          case "$dc" in
            gcp:*) ;;
            gcp) ;;
            *) dc="gcp:${dc}" ;;
          esac
          echo "datacenter=$dc" >> "$GITHUB_OUTPUT"
          echo "Resolved datacenter: $dc"

      - name: Ensure GCP llm capacity for private-llm
        if: steps.cfg_llm.outputs.configured == 'true'
        id: preflight_llm
        uses: ./.github/actions/preflight-gcp
        with:
          control_plane_url: ${{ env.CP_URL }}
          node_size: llm
          wait_seconds: "1800"
          billing_account_id: ${{ steps.billing_llm.outputs.billing_account_id }}
          billing_api_key: ${{ steps.billing_llm.outputs.billing_api_key }}
          billing_months: "1"
          gcp_datacenter: ${{ steps.target.outputs.datacenter }}
          gcp_project_id: ${{ env.GCP_PROJECT_ID }}
          gcp_service_account_key: ${{ env.GCP_SERVICE_ACCOUNT_KEY }}
          gcp_zone: ${{ vars.GCP_ZONE || 'us-central1-a,us-central1-b,us-central1-c,us-central1-f,us-east4-a,us-west1-b' }}
          cp_admin_token: ${{ env.CP_ADMIN_TOKEN || secrets.CP_ADMIN_TOKEN }}
          cp_admin_password: ${{ secrets.CP_ADMIN_PASSWORD }}

      - name: Ensure app exists (idempotent)
        if: steps.cfg_llm.outputs.configured == 'true'
        uses: ./.github/actions/register-app
        with:
          name: private-llm
          description: "Private LLM - Ollama running in a TDX enclave"
          control_plane_url: ${{ env.CP_URL }}

      - name: Deploy to EasyEnclave (GCP)
        if: steps.cfg_llm.outputs.configured == 'true'
        id: deploy
        uses: ./.github/actions/gcp-deploy-example
        with:
          app_name: private-llm
          compose_file: ${{ steps.llm_compose.outputs.compose_file }}
          service_name: private-llm
          health_endpoint: /
          control_plane_url: ${{ env.CP_URL }}
          agent_admin_password: ${{ secrets.AGENT_ADMIN_PASSWORD }}
          github_owner: ${{ github.repository_owner }}
          node_size: llm
          gcp_datacenter: ${{ vars.GCP_DATACENTER || 'gcp:us-central1-a' }}
          billing_account_id: ${{ steps.billing_llm.outputs.billing_account_id }}
          billing_api_key: ${{ steps.billing_llm.outputs.billing_api_key }}
          billing_months: "1"
          gcp_project_id: ${{ env.GCP_PROJECT_ID }}
          gcp_service_account_key: ${{ env.GCP_SERVICE_ACCOUNT_KEY }}
          gcp_zone: ${{ vars.GCP_ZONE || 'us-central1-a,us-central1-b,us-central1-c,us-central1-f,us-east4-a,us-west1-b' }}
          cp_admin_token: ${{ env.CP_ADMIN_TOKEN || secrets.CP_ADMIN_TOKEN }}
          cp_admin_password: ${{ secrets.CP_ADMIN_PASSWORD }}

      - name: Set up Python
        if: steps.cfg_llm.outputs.configured == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install SDK and OpenAI client
        if: steps.cfg_llm.outputs.configured == 'true'
        run: pip install ./sdk/ openai

      - name: Smoke test private-llm (OpenAI-compatible)
        if: steps.cfg_llm.outputs.configured == 'true'
        env:
          SERVICE_URL: ${{ steps.deploy.outputs.service_url }}
          EASYENCLAVE_URL: ${{ env.CP_URL }}
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import os
          import time

          import httpx
          import httpx as _httpx
          from easyenclave import EasyEnclaveClient
          from openai import OpenAI

          MODEL = "smollm2:135m"
          CHAT_PATH = "/v1/chat/completions"
          CHAT_BODY = {
              "model": MODEL,
              "messages": [{"role": "user", "content": "Say hello in one sentence."}],
          }
          TIMEOUT = 300
          RETRY_INTERVAL = 15

          service_url = os.environ["SERVICE_URL"].rstrip("/")
          easyenclave_url = os.environ["EASYENCLAVE_URL"].rstrip("/")

          def wait_ready(label, fn):
              deadline = time.monotonic() + TIMEOUT
              last_error = RuntimeError("unknown")
              while True:
                  try:
                      content = fn()
                      if content and content != "null":
                          print(f"[{label}] OK: {content}")
                          return
                  except Exception as exc:
                      last_error = exc
                  if time.monotonic() >= deadline:
                      raise RuntimeError(
                          f"[{label}] FAIL: not ready after {TIMEOUT}s â€” {last_error}"
                      )
                  print(f"[{label}] Model not ready, retrying in {RETRY_INTERVAL}s...")
                  time.sleep(RETRY_INTERVAL)

          def extract_content(resp: httpx.Response) -> str:
              data = resp.json()
              return data["choices"][0]["message"]["content"]

          def direct_call():
              url = f"{service_url}{CHAT_PATH}"
              with httpx.Client(timeout=60, headers={"user-agent": "EasyEnclave-Test/1.0"}) as c:
                  resp = c.post(url, json=CHAT_BODY)
                  resp.raise_for_status()
                  return extract_content(resp)

          ee = EasyEnclaveClient(easyenclave_url, verify=False)
          llm = ee.service("private-llm")

          def proxy_call():
              resp = llm.post(CHAT_PATH, json=CHAT_BODY, timeout=60)
              resp.raise_for_status()
              return extract_content(resp)

          def _strip_bot_headers(req: _httpx.Request):
              req.headers["user-agent"] = "EasyEnclave-Test/1.0"
              for key in [k for k in req.headers if k.lower().startswith("x-stainless-")]:
                  del req.headers[key]

          openai_client = OpenAI(
              base_url=f"{llm.base_url.rstrip('/')}/v1",
              api_key="unused",
              http_client=_httpx.Client(
                  verify=False,
                  event_hooks={"request": [_strip_bot_headers]},
              ),
          )

          def openai_call():
              completion = openai_client.chat.completions.create(
                  model=MODEL,
                  messages=[{"role": "user", "content": "Say hello in one sentence."}],
                  timeout=60,
              )
              return completion.choices[0].message.content or ""

          wait_ready("direct", direct_call)
          wait_ready("proxy", proxy_call)
          wait_ready("openai", openai_call)
          PY

      - name: Resolve admin token for LLM teardown
        id: teardown_auth
        if: always() && steps.cfg_llm.outputs.configured == 'true' && steps.deploy.outcome == 'success'
        shell: bash
        env:
          CP_ADMIN_TOKEN: ${{ env.CP_ADMIN_TOKEN || secrets.CP_ADMIN_TOKEN }}
          CP_ADMIN_PASSWORD: ${{ secrets.CP_ADMIN_PASSWORD }}
        run: |
          set -euo pipefail
          token="$(echo "${CP_ADMIN_TOKEN:-}" | xargs)"
          if [ -z "$token" ] && [ -n "${CP_ADMIN_PASSWORD:-}" ]; then
            payload="$(jq -cn --arg p "${CP_ADMIN_PASSWORD}" '{password: $p}')"
            token="$(curl -sS -X POST "$CP_URL/admin/login" -H 'Content-Type: application/json' -d "$payload" | jq -r '.token // empty' 2>/dev/null || true)"
          fi
          if [ -z "$token" ]; then
            echo "::error::Could not resolve admin token for teardown (set CP_ADMIN_TOKEN or CP_ADMIN_PASSWORD)."
            exit 1
          fi
          echo "::add-mask::$token"
          echo "admin_token=$token" >> "$GITHUB_OUTPUT"
          echo "Resolved admin token for teardown."

      - name: Teardown private-llm GCP deployment and capacity
        if: always() && steps.cfg_llm.outputs.configured == 'true' && steps.deploy.outcome == 'success'
        shell: bash
        env:
          ADMIN_TOKEN: ${{ steps.teardown_auth.outputs.admin_token }}
          AGENT_ID: ${{ steps.deploy.outputs.agent_id }}
          GCP_DC: ${{ steps.target.outputs.datacenter }}
        run: |
          set -euo pipefail
          if [ -z "${AGENT_ID:-}" ]; then
            echo "::warning::No deployed agent_id output; skipping teardown."
            exit 0
          fi
          if [ -z "${ADMIN_TOKEN:-}" ]; then
            echo "::warning::Missing admin token; cannot teardown deployed agent/capacity."
            exit 0
          fi
          dc="$(echo "${GCP_DC:-gcp:us-central1-a}" | tr '[:upper:]' '[:lower:]' | xargs)"
          echo "Teardown target: agent=$AGENT_ID datacenter=$dc node_size=llm"

          undeploy_code="$(curl -sS -o /tmp/undeploy.json -w "%{http_code}" \
            -X POST "$CP_URL/api/v1/agents/${AGENT_ID}/undeploy" \
            -H "Authorization: Bearer ${ADMIN_TOKEN}" \
            -H 'Accept: application/json' || true)"
          if [ "$undeploy_code" -lt 400 ]; then
            echo "Undeploy succeeded for agent ${AGENT_ID}."
          else
            echo "::warning::Undeploy failed (HTTP $undeploy_code): $(cat /tmp/undeploy.json)"
          fi

          cleanup_body="$(jq -cn --arg reason "ci:gcp-private-llm-post-test-teardown" '{dry_run:false, reason:$reason}')"
          cleanup_code="$(curl -sS -o /tmp/cleanup-agent.json -w "%{http_code}" \
            -X POST "$CP_URL/api/v1/admin/agents/${AGENT_ID}/cleanup" \
            -H "Authorization: Bearer ${ADMIN_TOKEN}" \
            -H 'Content-Type: application/json' \
            -d "$cleanup_body" || true)"
          if [ "$cleanup_code" -lt 400 ]; then
            echo "Agent cleanup succeeded for ${AGENT_ID}."
          else
            echo "::warning::Agent cleanup failed (HTTP $cleanup_code): $(cat /tmp/cleanup-agent.json)"
          fi

          target_code="$(curl -sS -o /tmp/cleanup-target.json -w "%{http_code}" \
            -X DELETE "$CP_URL/api/v1/admin/agents/capacity/targets?datacenter=${dc}&node_size=llm" \
            -H "Authorization: Bearer ${ADMIN_TOKEN}" \
            -H 'Accept: application/json' || true)"
          if [ "$target_code" -lt 400 ] || [ "$target_code" = "404" ]; then
            echo "Capacity target cleanup complete for ${dc}/llm (HTTP ${target_code})."
          else
            echo "::warning::Capacity target cleanup failed (HTTP $target_code): $(cat /tmp/cleanup-target.json)"
          fi

          agents_json="$(curl -sS -H "Authorization: Bearer ${ADMIN_TOKEN}" -H 'Accept: application/json' "$CP_URL/api/v1/agents" || true)"
          mapfile -t stale_ids < <(
            echo "$agents_json" | jq -r --arg dc "$dc" '
              [.agents[]?
                | select((.verified // false) == false)
                | select((.node_size // "" | ascii_downcase) == "llm")
                | select((.datacenter // "" | ascii_downcase) == $dc)
                | select((.vm_name // "") | startswith("ee-llm-"))
                | .agent_id] | unique[]?' 2>/dev/null || true
          )
          if [ "${#stale_ids[@]}" -gt 0 ]; then
            echo "Cleaning up ${#stale_ids[@]} unverified llm agent(s) in ${dc}..."
            for stale_id in "${stale_ids[@]}"; do
              curl -sS -X POST "$CP_URL/api/v1/admin/agents/${stale_id}/cleanup" \
                -H "Authorization: Bearer ${ADMIN_TOKEN}" \
                -H 'Content-Type: application/json' \
                -d "$cleanup_body" >/dev/null || true
            done
          else
            echo "No unverified ee-llm-* agents found in ${dc}."
          fi
