name: 'Publish EasyEnclave App Version'
description: 'Publish a new version of an app to EasyEnclave with source inspection and attestation'
author: 'EasyEnclave'

branding:
  icon: 'upload-cloud'
  color: 'blue'

inputs:
  app_name:
    description: 'Name of the registered app'
    required: true
  version:
    description: 'Version string (e.g., 1.0.0). Defaults to git tag.'
    required: false
  compose_file:
    description: 'Path to docker-compose.yml'
    required: false
    default: 'docker-compose.yml'
  image_digest:
    description: 'Docker image digest (sha256:...)'
    required: false
  source_commit:
    description: 'Git commit SHA. Defaults to current commit.'
    required: false
  source_tag:
    description: 'Git tag. Defaults to current ref if a tag.'
    required: false
  control_plane_url:
    description: 'EasyEnclave control plane URL'
    required: false
    default: 'https://app.easyenclave.com'
  node_size:
    description: 'Target node size for attestation (e.g., "tiny", "standard", "llm"). Empty = default.'
    required: false
    default: ''

outputs:
  version:
    description: 'The final published version string (may differ if conflict resolution was needed)'
    value: ${{ steps.publish.outputs.version }}
  version_id:
    description: 'The published version ID'
    value: ${{ steps.publish.outputs.version_id }}
  status:
    description: 'Version status (attested, rejected, failed)'
    value: ${{ steps.publish.outputs.status }}
  rejection_reason:
    description: 'Reason for rejection if status is rejected'
    value: ${{ steps.publish.outputs.rejection_reason }}
  mrtd:
    description: 'TDX measurement (if attested)'
    value: ${{ steps.publish.outputs.mrtd }}

runs:
  using: 'composite'
  steps:
    - name: Publish version
      id: publish
      shell: bash
      run: |
        # Determine version
        VERSION="${{ inputs.version }}"
        if [ -z "$VERSION" ]; then
          # Try to use git tag
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            echo "Error: version is required when not running on a tag"
            exit 1
          fi
        fi

        # Determine source_commit
        SOURCE_COMMIT="${{ inputs.source_commit }}"
        if [ -z "$SOURCE_COMMIT" ]; then
          SOURCE_COMMIT="${{ github.sha }}"
        fi

        # Determine source_tag
        SOURCE_TAG="${{ inputs.source_tag }}"
        if [ -z "$SOURCE_TAG" ] && [[ "${{ github.ref }}" == refs/tags/* ]]; then
          SOURCE_TAG="${{ github.ref_name }}"
        fi

        # Read and base64 encode compose file
        if [ ! -f "${{ inputs.compose_file }}" ]; then
          echo "Error: compose file not found: ${{ inputs.compose_file }}"
          exit 1
        fi
        COMPOSE_B64=$(base64 -w 0 "${{ inputs.compose_file }}")

        # Always prefer a fresh version. If a conflict occurs, mint a new unique
        # suffix and retry once instead of reusing an existing failed/stale version.
        post_version() {
          local req="$1"
          local tmp
          tmp="$(mktemp)"
          http_code="$(
            curl -sS -o "$tmp" -w "%{http_code}" \
              -X POST "${{ inputs.control_plane_url }}/api/v1/apps/${{ inputs.app_name }}/versions" \
              -H "Content-Type: application/json" \
              -d "$req"
          )"
          RESPONSE="$(cat "$tmp")"
          rm -f "$tmp"
        }

        attempts=0
        while :; do
          REQUEST=$(jq -n \
            --arg version "$VERSION" \
            --arg compose "$COMPOSE_B64" \
            --arg image_digest "${{ inputs.image_digest }}" \
            --arg source_commit "$SOURCE_COMMIT" \
            --arg source_tag "$SOURCE_TAG" \
            --arg node_size "${{ inputs.node_size }}" \
            '{
              version: $version,
              compose: $compose,
              source_commit: $source_commit
            }
            + (if $image_digest != "" then {image_digest: $image_digest} else {} end)
            + (if $source_tag != "" then {source_tag: $source_tag} else {} end)
            + (if $node_size != "" then {node_size: $node_size} else {} end)')

          post_version "$REQUEST"
          if [ "$http_code" -lt 400 ]; then
            break
          fi

          detail="$(echo "$RESPONSE" | jq -r '.detail // empty' 2>/dev/null || true)"
          if echo "$detail" | grep -qi "already exists" && [ "$attempts" -lt 1 ]; then
            attempts=$((attempts + 1))
            suffix="$(date -u +%Y%m%d%H%M%S)-$RANDOM"
            VERSION="${VERSION}-${suffix}"
            echo "::warning::Version already exists for ${{ inputs.app_name }}; retrying with fresh version $VERSION"
            continue
          fi

          if [ -n "$detail" ]; then
            echo "Error: $detail"
          else
            echo "Error: publish failed (HTTP $http_code)"
            echo "$RESPONSE"
          fi
          exit 1
        done

        # Extract outputs
        VERSION_ID=$(echo "$RESPONSE" | jq -r '.version_id')
        STATUS=$(echo "$RESPONSE" | jq -r '.status')
        REJECTION_REASON=$(echo "$RESPONSE" | jq -r '.rejection_reason // empty')
        MRTD=$(echo "$RESPONSE" | jq -r '.mrtd // empty')

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "version_id=$VERSION_ID" >> $GITHUB_OUTPUT
        echo "status=$STATUS" >> $GITHUB_OUTPUT
        echo "rejection_reason=$REJECTION_REASON" >> $GITHUB_OUTPUT
        echo "mrtd=$MRTD" >> $GITHUB_OUTPUT

        echo "Published version: ${{ inputs.app_name }}@$VERSION"
        echo "Status: $STATUS"

        # Fail if rejected
        if [ "$STATUS" = "rejected" ]; then
          echo "Version rejected: $REJECTION_REASON"
          exit 1
        fi

        echo "Version ID: $VERSION_ID"
        if [ -n "$MRTD" ]; then
          echo "MRTD: $MRTD"
        fi
