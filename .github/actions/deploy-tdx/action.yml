name: 'TDX Deploy'
description: 'Deploy workload to a running TDX agent via control plane API'
author: 'EasyEnclave'

branding:
  icon: 'upload-cloud'
  color: 'purple'

inputs:
  agent_id:
    description: 'Target agent ID (required)'
    required: true
  easyenclave_api_url:
    description: 'EasyEnclave control plane URL'
    default: 'https://app.easyenclave.com'
  docker_compose_path:
    description: 'Path to docker-compose.yml'
    default: './docker-compose.yml'
  service_name:
    description: 'Service name for EasyEnclave registration'
    required: false
  service_url:
    description: 'Public URL of the deployed service'
    required: false
  intel_api_key:
    description: 'Intel Trust Authority API key'
    required: false
  intel_api_url:
    description: 'Intel Trust Authority API URL'
    default: 'https://api.trustauthority.intel.com'
  health_endpoint:
    description: 'Health check endpoint path'
    default: '/health'
  compose_up_args:
    description: 'Arguments for docker compose up'
    default: '--build -d'
  source_repo:
    description: 'Source repository URL for registration'
    default: ''
  tags:
    description: 'JSON array of tags for EasyEnclave registration'
    default: '[]'
  wait_timeout:
    description: 'Timeout in seconds to wait for deployment'
    default: '600'

outputs:
  deployment_id:
    description: 'Deployment ID'
    value: ${{ steps.submit.outputs.deployment_id }}
  service_id:
    description: 'EasyEnclave service ID'
    value: ${{ steps.wait.outputs.service_id }}
  mrtd:
    description: 'TDX MRTD measurement'
    value: ${{ steps.wait.outputs.mrtd }}
  attestation_json:
    description: 'Full attestation JSON'
    value: ${{ steps.wait.outputs.attestation_json }}

runs:
  using: 'composite'
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        if [ -z "${{ inputs.agent_id }}" ]; then
          echo "::error::agent_id is required"
          exit 1
        fi
        if [ ! -f "${{ inputs.docker_compose_path }}" ]; then
          echo "::error::Docker compose file not found: ${{ inputs.docker_compose_path }}"
          exit 1
        fi

    - name: Submit deployment
      id: submit
      shell: bash
      run: |
        API_URL="${{ inputs.easyenclave_api_url }}"

        # Base64 encode the compose file
        COMPOSE_B64=$(base64 -w0 "${{ inputs.docker_compose_path }}")

        # Build source repo URL
        SOURCE_REPO="${{ inputs.source_repo }}"
        if [ -z "$SOURCE_REPO" ]; then
          SOURCE_REPO="https://github.com/${{ github.repository }}"
        fi

        # Build config JSON
        CONFIG=$(cat <<EOF
        {
          "service_name": "${{ inputs.service_name }}",
          "service_url": "${{ inputs.service_url }}",
          "intel_api_key": "${{ inputs.intel_api_key }}",
          "intel_api_url": "${{ inputs.intel_api_url }}",
          "health_endpoint": "${{ inputs.health_endpoint }}",
          "compose_up_args": "${{ inputs.compose_up_args }}",
          "source_repo": "$SOURCE_REPO",
          "source_commit": "${{ github.sha }}",
          "tags": ${{ inputs.tags }}
        }
        EOF
        )

        # Submit deployment to control plane
        RESPONSE=$(curl -s -X POST "${API_URL}/api/v1/deployments" \
          -H "Content-Type: application/json" \
          -d "{
            \"agent_id\": \"${{ inputs.agent_id }}\",
            \"compose\": \"${COMPOSE_B64}\",
            \"build_context\": {},
            \"config\": ${CONFIG}
          }")

        DEPLOYMENT_ID=$(echo "$RESPONSE" | jq -r '.deployment_id // empty')

        if [ -z "$DEPLOYMENT_ID" ]; then
          echo "::error::Failed to submit deployment"
          echo "$RESPONSE"
          exit 1
        fi

        echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
        echo "Deployment submitted: $DEPLOYMENT_ID"

    - name: Wait for deployment
      id: wait
      shell: bash
      run: |
        API_URL="${{ inputs.easyenclave_api_url }}"
        DEPLOYMENT_ID="${{ steps.submit.outputs.deployment_id }}"
        TIMEOUT="${{ inputs.wait_timeout }}"

        echo "Waiting for deployment to complete (timeout: ${TIMEOUT}s)..."

        START_TIME=$(date +%s)
        while true; do
          CURRENT_TIME=$(date +%s)
          ELAPSED=$((CURRENT_TIME - START_TIME))

          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "::error::Timeout waiting for deployment after ${TIMEOUT}s"
            exit 1
          fi

          # Check deployment status
          RESPONSE=$(curl -s "${API_URL}/api/v1/deployments/${DEPLOYMENT_ID}")
          STATUS=$(echo "$RESPONSE" | jq -r '.status')

          case "$STATUS" in
            "completed")
              SERVICE_ID=$(echo "$RESPONSE" | jq -r '.service_id // empty')
              ATTESTATION=$(echo "$RESPONSE" | jq -c '.attestation // {}')
              MRTD=$(echo "$ATTESTATION" | jq -r '.tdx.measurements.mrtd // empty')

              echo "service_id=$SERVICE_ID" >> $GITHUB_OUTPUT
              echo "mrtd=$MRTD" >> $GITHUB_OUTPUT
              echo "attestation_json=$ATTESTATION" >> $GITHUB_OUTPUT

              echo ""
              echo "Deployment completed successfully!"
              exit 0
              ;;
            "failed")
              ERROR=$(echo "$RESPONSE" | jq -r '.error // "Unknown error"')
              echo "::error::Deployment failed: $ERROR"
              exit 1
              ;;
            *)
              echo "  Status: $STATUS (${ELAPSED}s elapsed)"
              ;;
          esac

          sleep 5
        done

    - name: Summary
      shell: bash
      run: |
        echo ""
        echo "========================================="
        echo "TDX Deploy Complete"
        echo "========================================="
        echo ""
        echo "Deployment ID: ${{ steps.submit.outputs.deployment_id }}"
        echo "Service ID:    ${{ steps.wait.outputs.service_id }}"
        echo "MRTD:          ${{ steps.wait.outputs.mrtd }}"
        echo ""
        if [ -n "${{ inputs.service_url }}" ]; then
          echo "Service URL:   ${{ inputs.service_url }}"
        fi
        echo ""
        echo "========================================="
