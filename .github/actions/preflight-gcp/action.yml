name: Preflight - GCP capacity
description: Ensure at least one healthy verified GCP agent exists (provision one if needed)

inputs:
  control_plane_url:
    description: EasyEnclave control plane URL
    required: false
    default: "https://app.easyenclave.com"
  node_size:
    description: Agent node_size to provision (e.g. tiny)
    required: false
    default: "tiny"
  wait_seconds:
    description: Seconds to wait for agent registration
    required: false
    default: "900"

  # Control plane admin (optional but enables baseline auto-trust).
  cp_admin_token:
    description: Control plane admin token (preferred)
    required: false
    default: ""
  cp_admin_password:
    description: Control plane admin password (fallback)
    required: false
    default: ""

  # Required for agent registration.
  intel_api_key:
    description: Intel TA API key used by the agent to register/attest
    required: false
    default: ""

  # GCP auth + project selection.
  gcp_project_id:
    description: GCP project ID
    required: true
  gcp_wif_provider:
    description: GCP workload identity provider (OIDC)
    required: false
    default: ""
  gcp_wif_service_account:
    description: GCP service account email for OIDC
    required: false
    default: ""
  gcp_service_account_key:
    description: JSON service account key (fallback auth)
    required: false
    default: ""

  # Placement / sizing. CSV lists are supported for zone and machine type.
  gcp_zone:
    description: Comma-separated zones to try
    required: false
    default: "us-central1-a,us-central1-b,us-central1-c,us-central1-f,us-east4-a,us-west1-b"
  gcp_region:
    description: Region for resource grouping
    required: false
    default: "us-central1"
  gcp_machine_type:
    description: Comma-separated machine types to try
    required: false
    default: "c3-standard-2,c3-standard-4"
  gcp_boot_disk_size:
    description: Boot disk size (e.g. 30GB)
    required: false
    default: "30GB"

outputs:
  gcp_eligible_agents:
    description: Count of eligible verified healthy GCP agents after preflight
    value: ${{ steps.final.outputs.gcp_eligible_agents }}
  gcp_provisioned:
    description: Whether the action attempted provisioning (true/false)
    value: ${{ steps.final.outputs.gcp_provisioned }}

runs:
  using: composite
  steps:
    - name: Get control-plane admin token (optional)
      id: cp_admin
      shell: bash
      env:
        CP_URL: ${{ inputs.control_plane_url }}
        CP_ADMIN_TOKEN: ${{ inputs.cp_admin_token }}
        CP_ADMIN_PASSWORD: ${{ inputs.cp_admin_password }}
      run: |
        set -euo pipefail

        if [ -n "${CP_ADMIN_TOKEN:-}" ]; then
          echo "Using CP admin token from inputs"
          echo "cp_admin_token=$CP_ADMIN_TOKEN" >> "$GITHUB_OUTPUT"
          echo "CP_ADMIN_TOKEN=$CP_ADMIN_TOKEN" >> "$GITHUB_ENV"
          exit 0
        fi

        pw="${CP_ADMIN_PASSWORD:-}"
        if [ -z "$pw" ]; then
          # Backward compat: CI control plane sometimes exposes an auto-generated password.
          pw="$(curl -sSf "$CP_URL/auth/methods" | jq -r '.generated_password // empty' || true)"
        fi

        if [ -z "$pw" ]; then
          echo "::warning::No CP admin password available; provisioning can still create a VM, but it likely cannot be auto-trusted."
          exit 0
        fi

        resp="$(curl -sSf -X POST "$CP_URL/admin/login" -H "Content-Type: application/json" -d "{\"password\":\"$pw\"}")"
        token="$(echo "$resp" | jq -r '.token // empty')"
        if [ -z "$token" ] || [ "$token" = "null" ]; then
          echo "::warning::Failed to obtain CP admin token via password login."
          echo "$resp" | jq . || true
          exit 0
        fi

        echo "cp_admin_token=$token" >> "$GITHUB_OUTPUT"
        echo "CP_ADMIN_TOKEN=$token" >> "$GITHUB_ENV"

    - name: Precheck - healthy verified GCP agents
      id: precheck
      shell: bash
      env:
        CP_URL: ${{ inputs.control_plane_url }}
      run: |
        set -euo pipefail
        agents="$(curl -sSf -H 'Accept: application/json' "$CP_URL/api/v1/agents")"
        count="$(
          echo "${agents:-}" | jq '
            [.agents[]
              | (.datacenter // "" | ascii_downcase) as $dc
              | (.status // "" | ascii_downcase) as $st
              | select(.verified == true
                and (.health_status // "" | ascii_downcase) == "healthy"
                and ($st == "undeployed" or ($st == "deployed" and ((.deployed_app // "") | test("^measuring-enclave") | not)))
                and ($dc | startswith("gcp:") or $dc == "gcp"))
            ] | length
          ' 2>/dev/null || echo 0
        )"

        echo "gcp_eligible_agents=$count" >> "$GITHUB_OUTPUT"

        if [ "$count" -gt 0 ]; then
          echo "Found $count eligible GCP agents."
          echo "need_provision=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        echo "need_provision=true" >> "$GITHUB_OUTPUT"
        echo "::warning::No healthy verified GCP agents available; provisioning one now."

    - name: Validate GCP secrets (only if provisioning)
      if: steps.precheck.outputs.need_provision == 'true'
      shell: bash
      env:
        INTEL_API_KEY: ${{ inputs.intel_api_key }}
        CP_ADMIN_TOKEN: ${{ steps.cp_admin.outputs.cp_admin_token }}
        GCP_PROJECT_ID: ${{ inputs.gcp_project_id }}
        GCP_WIF_PROVIDER: ${{ inputs.gcp_wif_provider }}
        GCP_WIF_SERVICE_ACCOUNT: ${{ inputs.gcp_wif_service_account }}
        GCP_SERVICE_ACCOUNT_KEY: ${{ inputs.gcp_service_account_key }}
      run: |
        set -euo pipefail
        if [ -z "${INTEL_API_KEY:-}" ]; then
          echo "::error::Missing intel_api_key (needed for agent registration)"
          exit 1
        fi
        if [ -z "${CP_ADMIN_TOKEN:-}" ]; then
          echo "::warning::CP admin token is not set; provisioning may succeed but the agent may remain unverified until an admin trusts its MRTD baseline."
        fi
        if [ -z "${GCP_PROJECT_ID:-}" ]; then
          echo "::error::Missing gcp_project_id"
          exit 1
        fi
        if [ -n "${GCP_WIF_PROVIDER:-}" ] && [ -n "${GCP_WIF_SERVICE_ACCOUNT:-}" ]; then
          echo "GCP auth mode: OIDC"
        elif [ -n "${GCP_SERVICE_ACCOUNT_KEY:-}" ]; then
          echo "::warning::GCP OIDC not configured; using service-account-key fallback"
        else
          echo "::error::GCP auth is not configured (missing OIDC inputs and service-account key)"
          exit 1
        fi

    - name: Authenticate to Google Cloud (OIDC)
      if: steps.precheck.outputs.need_provision == 'true' && inputs.gcp_wif_provider != '' && inputs.gcp_wif_service_account != ''
      uses: google-github-actions/auth@v2
      with:
        workload_identity_provider: ${{ inputs.gcp_wif_provider }}
        service_account: ${{ inputs.gcp_wif_service_account }}

    - name: Authenticate to Google Cloud (service account key fallback)
      if: steps.precheck.outputs.need_provision == 'true' && inputs.gcp_wif_provider == '' && inputs.gcp_service_account_key != ''
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ inputs.gcp_service_account_key }}

    - name: Setup gcloud
      if: steps.precheck.outputs.need_provision == 'true'
      uses: google-github-actions/setup-gcloud@v2

    - name: Provision GCP agent and auto-trust MRTD baseline
      if: steps.precheck.outputs.need_provision == 'true'
      id: provision
      shell: bash
      env:
        CP_URL: ${{ inputs.control_plane_url }}
        CP_ADMIN_TOKEN: ${{ steps.cp_admin.outputs.cp_admin_token }}
        INTEL_API_KEY: ${{ inputs.intel_api_key }}
        NODE_SIZE: ${{ inputs.node_size }}
        WAIT_SECONDS: ${{ inputs.wait_seconds }}
        GCP_PROJECT_ID: ${{ inputs.gcp_project_id }}
        GCP_ZONE: ${{ inputs.gcp_zone }}
        GCP_REGION: ${{ inputs.gcp_region }}
        GCP_MACHINE_TYPE: ${{ inputs.gcp_machine_type }}
        GCP_BOOT_DISK_SIZE: ${{ inputs.gcp_boot_disk_size }}
      run: |
        set -euo pipefail
        RUN_TAG="deploy-examples-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
        echo "RUN_TAG=$RUN_TAG" >> "$GITHUB_ENV"
        LAUNCHER_URL="https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/${GITHUB_SHA}/infra/launcher/launcher.py"

        cleanup() {
          echo "::warning::Provisioning failed; cleaning up managed GCP resources for run-tag=$RUN_TAG"
          python3 scripts/cloud_provisioner.py cleanup \
            --provider gcp \
            --run-id "$RUN_TAG" \
            --gcp-project "$GCP_PROJECT_ID" \
            --gcp-zone "$GCP_ZONE" \
            --gcp-region "$GCP_REGION" || true
        }

        trap cleanup ERR
        python3 scripts/cloud_provisioner.py provision \
          --provider gcp \
          --run-id "$RUN_TAG" \
          --cp-url "$CP_URL" \
          --cp-admin-token="$CP_ADMIN_TOKEN" \
          --intel-api-key "$INTEL_API_KEY" \
          --node-size "$NODE_SIZE" \
          --launcher-url "$LAUNCHER_URL" \
          --gcp-project "$GCP_PROJECT_ID" \
          --gcp-zone "$GCP_ZONE" \
          --gcp-region "$GCP_REGION" \
          --gcp-machine-type "$GCP_MACHINE_TYPE" \
          --gcp-boot-disk-size "$GCP_BOOT_DISK_SIZE" \
          --gcp-count 1 \
          --wait-registration \
          --wait-seconds "$WAIT_SECONDS"
        trap - ERR

    - name: Final check - healthy verified GCP agents
      id: final
      shell: bash
      env:
        CP_URL: ${{ inputs.control_plane_url }}
      run: |
        set -euo pipefail
        agents="$(curl -sSf -H 'Accept: application/json' "$CP_URL/api/v1/agents")"
        count="$(
          echo "${agents:-}" | jq '
            [.agents[]
              | (.datacenter // "" | ascii_downcase) as $dc
              | (.status // "" | ascii_downcase) as $st
              | select(.verified == true
                and (.health_status // "" | ascii_downcase) == "healthy"
                and ($st == "undeployed" or ($st == "deployed" and ((.deployed_app // "") | test("^measuring-enclave") | not)))
                and ($dc | startswith("gcp:") or $dc == "gcp"))
            ] | length
          ' 2>/dev/null || echo 0
        )"

        echo "gcp_eligible_agents=$count" >> "$GITHUB_OUTPUT"
        echo "gcp_provisioned=${{ steps.precheck.outputs.need_provision == 'true' }}" >> "$GITHUB_OUTPUT"

        if [ "$count" -le 0 ]; then
          echo "::error::No eligible verified GCP agents available after provisioning attempt."
          echo "::error::This should only happen if GCP provisioning failed or the control plane cannot verify/trust the agent."
          exit 1
        fi
        echo "Found $count eligible verified GCP agents."
