# Deploy to EasyEnclave - Composite Action
#
# Deploys a docker-compose.yml to a TDX agent via the EasyEnclave control plane.
# This action handles all the TDX complexity - users just need Docker files.
#
# IMPORTANT: The app must be pre-registered in the app catalog before deployment.
# Register apps via: POST /api/v1/apps or the register-app action.
#
# Usage:
#   - uses: easyenclave/easyenclave/.github/actions/deploy@main
#     with:
#       app_name: my-app
#       compose_file: docker-compose.yml
#       service_name: my-app

name: Deploy to EasyEnclave
description: Deploy a Docker Compose application to EasyEnclave's confidential computing platform

inputs:
  app_name:
    description: 'App name (must be pre-registered in the app catalog)'
    required: true
  compose_file:
    description: Path to docker-compose.yml file
    required: true
  service_name:
    description: Service name for deployment
    required: true
  health_endpoint:
    description: Health check endpoint path
    required: false
    default: '/health'
  control_plane_url:
    description: EasyEnclave control plane URL
    required: false
    default: 'https://app.easyenclave.com'
  trusted_mrtd:
    description: TDX VM image MRTD to trust (optional)
    required: false
    default: ''

outputs:
  deployment_id:
    description: The deployment ID
    value: ${{ steps.deploy.outputs.deployment_id }}
  agent_id:
    description: The agent ID used for deployment
    value: ${{ steps.deploy.outputs.agent_id }}
  service_url:
    description: The deployed service URL
    value: ${{ steps.deploy.outputs.service_url }}
  version:
    description: The published app version
    value: ${{ steps.deploy.outputs.version }}

runs:
  using: composite
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        if [ ! -f "${{ inputs.compose_file }}" ]; then
          echo "::error::Compose file not found: ${{ inputs.compose_file }}"
          exit 1
        fi
        echo "Deploying ${{ inputs.app_name }} from ${{ inputs.compose_file }}"

    - name: Deploy to EasyEnclave
      id: deploy
      shell: bash
      env:
        CONTROL_PLANE_URL: ${{ inputs.control_plane_url }}
        TRUSTED_MRTD: ${{ inputs.trusted_mrtd }}
        COMPOSE_FILE: ${{ inputs.compose_file }}
        APP_NAME: ${{ inputs.app_name }}
        SERVICE_NAME: ${{ inputs.service_name }}
        HEALTH_ENDPOINT: ${{ inputs.health_endpoint }}
      run: |
        set -e

        # Trust MRTD if provided
        if [ -n "$TRUSTED_MRTD" ]; then
          echo "Ensuring MRTD is trusted: ${TRUSTED_MRTD:0:32}..."
          curl -sf -X POST "$CONTROL_PLANE_URL/api/v1/trusted-mrtds" \
            -H "Content-Type: application/json" \
            -d "{\"mrtd\": \"$TRUSTED_MRTD\", \"description\": \"TDX runner image\"}" 2>/dev/null || true
        fi

        # Step 1: Verify app exists
        echo "Verifying app '$APP_NAME' is registered..."
        HTTP_CODE=$(curl -s -o /tmp/app_response.json -w "%{http_code}" \
          "$CONTROL_PLANE_URL/api/v1/apps/$APP_NAME" 2>/dev/null) || true

        if [ "$HTTP_CODE" != "200" ]; then
          echo "::error::App '$APP_NAME' is not registered (HTTP $HTTP_CODE). Please register the app first using:"
          echo "::error::  curl -X POST $CONTROL_PLANE_URL/api/v1/apps -H 'Content-Type: application/json' -d '{\"name\": \"$APP_NAME\", \"source_repo\": \"your-org/your-repo\"}'"
          echo "Response body: $(cat /tmp/app_response.json 2>/dev/null || echo 'empty')"
          exit 1
        fi
        echo "App '$APP_NAME' found"

        # Step 2: Generate version string (YYYYMMDD-HHMMSS-short_sha)
        TIMESTAMP=$(date -u +%Y%m%d-%H%M%S)
        SHORT_SHA="${GITHUB_SHA:0:7}"
        VERSION="${TIMESTAMP}-${SHORT_SHA}"
        echo "Generated version: $VERSION"
        echo "version=$VERSION" >> "$GITHUB_OUTPUT"

        # Step 3: Publish version
        echo "Publishing version $VERSION..."
        COMPOSE_B64=$(base64 -w0 "$COMPOSE_FILE")
        HTTP_CODE=$(curl -s -o /tmp/version_response.json -w "%{http_code}" \
          -X POST "$CONTROL_PLANE_URL/api/v1/apps/$APP_NAME/versions" \
          -H "Content-Type: application/json" \
          -d "{
            \"version\": \"$VERSION\",
            \"compose\": \"$COMPOSE_B64\",
            \"source_commit\": \"$GITHUB_SHA\"
          }")

        if [ "$HTTP_CODE" -ge 400 ]; then
          echo "::error::Failed to publish version: $(cat /tmp/version_response.json)"
          exit 1
        fi

        # Step 4: Check version status
        VERSION_STATUS=$(jq -r '.status' /tmp/version_response.json)
        echo "Version status: $VERSION_STATUS"

        if [ "$VERSION_STATUS" = "rejected" ]; then
          REJECTION_REASON=$(jq -r '.rejection_reason // "Unknown reason"' /tmp/version_response.json)
          echo "::error::Version was rejected by source inspection: $REJECTION_REASON"
          exit 1
        fi

        if [ "$VERSION_STATUS" != "attested" ]; then
          echo "::error::Version status is '$VERSION_STATUS', expected 'attested'"
          exit 1
        fi
        echo "Version $VERSION is attested"

        # Helper: Check if agent exists and is available
        check_agent_available() {
          local agent_id="$1"
          local http_code
          http_code=$(curl -s -o /tmp/agent_status.json -w "%{http_code}" \
            "$CONTROL_PLANE_URL/api/v1/agents/$agent_id" 2>/dev/null) || true
          if [ "$http_code" != "200" ]; then
            return 1
          fi
          local deploy_status
          deploy_status=$(jq -r '.status // "unknown"' /tmp/agent_status.json)
          [ "$deploy_status" = "deploying" ] && return 2
          return 0
        }

        # Helper: Find an available verified agent
        find_available_agent() {
          local agents_json
          agents_json=$(curl -sf "$CONTROL_PLANE_URL/api/v1/agents" 2>/dev/null || echo '{"agents":[]}')
          local agent_ids
          agent_ids=$(echo "$agents_json" | jq -r '[.agents[] | select(.verified == true)] | .[].agent_id')
          for agent_id in $agent_ids; do
            echo "  Checking agent $agent_id..." >&2
            check_agent_available "$agent_id"
            local result=$?
            if [ $result -eq 0 ]; then
              echo "$agent_id"
              return 0
            elif [ $result -eq 2 ]; then
              echo "    Agent is busy, skipping" >&2
            else
              echo "    Agent not found, skipping" >&2
            fi
          done
          return 1
        }

        # Step 5: Find available agent (retry for up to 3 minutes)
        echo "Looking for available agent..."
        AGENT_ID=""
        for attempt in {1..6}; do
          AGENT_ID=$(find_available_agent) || true
          if [ -n "$AGENT_ID" ]; then
            check_agent_available "$AGENT_ID"
            [ $? -eq 0 ] && break
            AGENT_ID=""
          fi
          if [ $attempt -lt 6 ]; then
            echo "No available agents, waiting 30s... ($attempt/6)"
            sleep 30
          fi
        done

        if [ -z "$AGENT_ID" ]; then
          echo "::error::No available agents found. Please ensure agents are running via the EasyEnclave control plane."
          exit 1
        fi
        echo "Using agent: $AGENT_ID"
        echo "agent_id=$AGENT_ID" >> "$GITHUB_OUTPUT"

        # Step 6: Deploy version
        echo "Deploying version $VERSION to agent $AGENT_ID..."
        HTTP_CODE=$(curl -s -o /tmp/deploy_response.json -w "%{http_code}" \
          -X POST "$CONTROL_PLANE_URL/api/v1/apps/$APP_NAME/versions/$VERSION/deploy" \
          -H "Content-Type: application/json" \
          -d "{
            \"agent_id\": \"$AGENT_ID\",
            \"config\": {
              \"service_name\": \"$SERVICE_NAME\",
              \"health_endpoint\": \"$HEALTH_ENDPOINT\"
            }
          }")

        RESPONSE=$(cat /tmp/deploy_response.json)
        echo "HTTP $HTTP_CODE"

        if [ "$HTTP_CODE" -ge 400 ]; then
          echo "::error::Deployment failed: $RESPONSE"
          exit 1
        fi

        DEPLOYMENT_ID=$(echo "$RESPONSE" | jq -r '.deployment_id')
        echo "Deployment ID: $DEPLOYMENT_ID"
        echo "deployment_id=$DEPLOYMENT_ID" >> "$GITHUB_OUTPUT"

        # Step 7: Wait for health (also check for deployment failures)
        echo "Waiting for deployment to become healthy..."
        for i in {1..60}; do
          # Check agent status
          AGENT_STATUS=$(curl -sf "$CONTROL_PLANE_URL/api/v1/agents/$AGENT_ID" 2>/dev/null || echo '{}')
          AGENT_STATE=$(echo "$AGENT_STATUS" | jq -r '.status // "unknown"')
          HEALTH=$(echo "$AGENT_STATUS" | jq -r '.health_status // "unknown"')
          SERVICE_URL=$(echo "$AGENT_STATUS" | jq -r '.service_url // empty')

          # Check if agent reported an error
          if [ "$AGENT_STATE" = "error" ]; then
            # Get deployment details for error message
            DEPLOY_STATUS=$(curl -sf "$CONTROL_PLANE_URL/api/v1/deployments/$DEPLOYMENT_ID" 2>/dev/null || echo '{}')
            DEPLOY_ERROR=$(echo "$DEPLOY_STATUS" | jq -r '.error // "Unknown error"')
            echo "::error::Deployment failed on agent: $DEPLOY_ERROR"
            echo ""
            echo "Debug info:"
            echo "  Agent ID: $AGENT_ID"
            echo "  Agent status: $AGENT_STATE"
            echo "  Deployment ID: $DEPLOYMENT_ID"
            echo "  Deployment status: $(echo "$DEPLOY_STATUS" | jq -r '.status // "unknown"')"
            exit 1
          fi

          # Check deployment status directly
          DEPLOY_STATUS=$(curl -sf "$CONTROL_PLANE_URL/api/v1/deployments/$DEPLOYMENT_ID" 2>/dev/null || echo '{}')
          DEPLOY_STATE=$(echo "$DEPLOY_STATUS" | jq -r '.status // "unknown"')

          if [ "$DEPLOY_STATE" = "failed" ]; then
            DEPLOY_ERROR=$(echo "$DEPLOY_STATUS" | jq -r '.error // "Unknown error"')
            echo "::error::Deployment failed: $DEPLOY_ERROR"
            echo ""
            echo "Debug info:"
            echo "  Agent ID: $AGENT_ID"
            echo "  Agent status: $AGENT_STATE"
            echo "  Deployment ID: $DEPLOYMENT_ID"
            exit 1
          fi

          if [ "$HEALTH" = "healthy" ] && [ -n "$SERVICE_URL" ]; then
            echo "Agent reports healthy at $SERVICE_URL"
            echo "service_url=$SERVICE_URL" >> "$GITHUB_OUTPUT"

            # Now wait for the tunnel to become accessible
            echo "Verifying tunnel connectivity..."
            for j in {1..30}; do
              if curl -sf "${SERVICE_URL}${HEALTH_ENDPOINT}" > /dev/null 2>&1; then
                echo "Tunnel verification passed!"
                curl -s "${SERVICE_URL}${HEALTH_ENDPOINT}" | head -c 500
                echo ""
                echo "Deployment complete!"
                exit 0
              fi
              echo "  Waiting for tunnel... ($j/30)"
              sleep 10
            done

            # Tunnel never became accessible
            echo "::error::Deployment completed but tunnel not accessible after 5 minutes"
            echo "Agent is healthy but ${SERVICE_URL}${HEALTH_ENDPOINT} is not reachable"
            exit 1
          fi

          echo "  Agent: $AGENT_STATE | Health: $HEALTH | Deploy: $DEPLOY_STATE ($i/60)"
          sleep 5
        done

        # On timeout, show more diagnostic info
        echo "::error::Deployment timed out waiting for health"
        echo ""
        echo "Final state:"
        echo "  Agent status: $(echo "$AGENT_STATUS" | jq -r '.status // "unknown"')"
        echo "  Agent health: $HEALTH"
        echo "  Agent service_url: $SERVICE_URL"
        echo "  Deployment status: $DEPLOY_STATE"
        echo "  Deployment error: $(echo "$DEPLOY_STATUS" | jq -r '.error // "none"')"
        exit 1
