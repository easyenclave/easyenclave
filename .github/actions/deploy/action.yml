# Deploy to EasyEnclave - Composite Action
#
# Deploys a docker-compose.yml to a TDX agent via the EasyEnclave control plane.
# This action handles all the TDX complexity - users just need Docker files.
#
# IMPORTANT: The app must be pre-registered in the app catalog before deployment.
# Register apps via: POST /api/v1/apps or the register-app action.
#
# Usage:
#   - uses: easyenclave/easyenclave/.github/actions/deploy@main
#     with:
#       app_name: my-app
#       compose_file: docker-compose.yml
#       service_name: my-app

name: Deploy to EasyEnclave
description: Deploy a Docker Compose application to EasyEnclave's confidential computing platform

inputs:
  app_name:
    description: 'App name (must be pre-registered in the app catalog)'
    required: true
  compose_file:
    description: Path to docker-compose.yml file
    required: true
  service_name:
    description: Service name for deployment
    required: true
  health_endpoint:
    description: Health check endpoint path
    required: false
    default: '/health'
  control_plane_url:
    description: EasyEnclave control plane URL
    required: false
    default: 'https://app.easyenclave.com'

outputs:
  deployment_id:
    description: The deployment ID
    value: ${{ steps.deploy.outputs.deployment_id }}
  agent_id:
    description: The agent ID used for deployment
    value: ${{ steps.find-agent.outputs.agent_id }}
  service_url:
    description: The deployed service URL
    value: ${{ steps.health.outputs.service_url }}
  version:
    description: The published app version
    value: ${{ steps.version.outputs.version }}

runs:
  using: composite
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        if [ ! -f "${{ inputs.compose_file }}" ]; then
          echo "::error::Compose file not found: ${{ inputs.compose_file }}"
          exit 1
        fi
        echo "Deploying ${{ inputs.app_name }} from ${{ inputs.compose_file }}"

    - name: Verify app is registered
      shell: bash
      run: |
        set -e
        echo "Verifying app '${{ inputs.app_name }}' is registered..."
        HTTP_CODE=$(curl -s -o /tmp/app_response.json -w "%{http_code}" \
          "${{ inputs.control_plane_url }}/api/v1/apps/${{ inputs.app_name }}" 2>/dev/null) || true

        if [ "$HTTP_CODE" != "200" ]; then
          echo "::error::App '${{ inputs.app_name }}' is not registered (HTTP $HTTP_CODE). Please register the app first using:"
          echo "::error::  curl -X POST ${{ inputs.control_plane_url }}/api/v1/apps -H 'Content-Type: application/json' -d '{\"name\": \"${{ inputs.app_name }}\", \"source_repo\": \"your-org/your-repo\"}'"
          echo "Response body: $(cat /tmp/app_response.json 2>/dev/null || echo 'empty')"
          exit 1
        fi
        echo "App '${{ inputs.app_name }}' found"

    - name: Generate version string
      id: version
      shell: bash
      run: |
        TIMESTAMP=$(date -u +%Y%m%d-%H%M%S)
        SHORT_SHA="${GITHUB_SHA:0:7}"
        VERSION="${TIMESTAMP}-${SHORT_SHA}"
        echo "Generated version: $VERSION"
        echo "version=$VERSION" >> "$GITHUB_OUTPUT"

    - name: Publish version
      id: publish
      uses: ./.github/actions/publish
      with:
        app_name: ${{ inputs.app_name }}
        version: ${{ steps.version.outputs.version }}
        compose_file: ${{ inputs.compose_file }}
        source_commit: ${{ github.sha }}
        control_plane_url: ${{ inputs.control_plane_url }}

    - name: Verify version is attested
      shell: bash
      run: |
        if [ "${{ steps.publish.outputs.status }}" != "attested" ]; then
          echo "::error::Version status is '${{ steps.publish.outputs.status }}', expected 'attested'"
          exit 1
        fi
        echo "Version ${{ steps.version.outputs.version }} is attested"

    - name: Find available agent
      id: find-agent
      shell: bash
      env:
        CONTROL_PLANE_URL: ${{ inputs.control_plane_url }}
      run: |
        set -e

        check_agent_available() {
          local agent_id="$1"
          local http_code
          http_code=$(curl -s -o /tmp/agent_status.json -w "%{http_code}" \
            "$CONTROL_PLANE_URL/api/v1/agents/$agent_id" 2>/dev/null) || true
          if [ "$http_code" != "200" ]; then
            return 1
          fi
          local deploy_status
          deploy_status=$(jq -r '.status // "unknown"' /tmp/agent_status.json)
          [ "$deploy_status" = "deploying" ] && return 2
          return 0
        }

        find_available_agent() {
          local agents_json
          agents_json=$(curl -sf "$CONTROL_PLANE_URL/api/v1/agents" 2>/dev/null || echo '{"agents":[]}')
          local agent_ids
          agent_ids=$(echo "$agents_json" | jq -r '[.agents[] | select(.verified == true)] | .[].agent_id')
          for agent_id in $agent_ids; do
            echo "  Checking agent $agent_id..." >&2
            check_agent_available "$agent_id"
            local result=$?
            if [ $result -eq 0 ]; then
              echo "$agent_id"
              return 0
            elif [ $result -eq 2 ]; then
              echo "    Agent is busy, skipping" >&2
            else
              echo "    Agent not found, skipping" >&2
            fi
          done
          return 1
        }

        echo "Looking for available agent..."
        AGENT_ID=""
        for attempt in {1..6}; do
          AGENT_ID=$(find_available_agent) || true
          if [ -n "$AGENT_ID" ]; then
            check_agent_available "$AGENT_ID"
            [ $? -eq 0 ] && break
            AGENT_ID=""
          fi
          if [ $attempt -lt 6 ]; then
            echo "No available agents, waiting 30s... ($attempt/6)"
            sleep 30
          fi
        done

        if [ -z "$AGENT_ID" ]; then
          echo "::error::No available agents found. Please ensure agents are running via the EasyEnclave control plane."
          exit 1
        fi
        echo "Using agent: $AGENT_ID"
        echo "agent_id=$AGENT_ID" >> "$GITHUB_OUTPUT"

    - name: Deploy version to agent
      id: deploy
      shell: bash
      run: |
        set -e
        echo "Deploying version ${{ steps.version.outputs.version }} to agent ${{ steps.find-agent.outputs.agent_id }}..."
        HTTP_CODE=$(curl -s -o /tmp/deploy_response.json -w "%{http_code}" \
          -X POST "${{ inputs.control_plane_url }}/api/v1/apps/${{ inputs.app_name }}/versions/${{ steps.version.outputs.version }}/deploy" \
          -H "Content-Type: application/json" \
          -d "{
            \"agent_id\": \"${{ steps.find-agent.outputs.agent_id }}\",
            \"config\": {
              \"service_name\": \"${{ inputs.service_name }}\",
              \"health_endpoint\": \"${{ inputs.health_endpoint }}\"
            }
          }")

        RESPONSE=$(cat /tmp/deploy_response.json)
        echo "HTTP $HTTP_CODE"

        if [ "$HTTP_CODE" -ge 400 ]; then
          echo "::error::Deployment failed: $RESPONSE"
          exit 1
        fi

        DEPLOYMENT_ID=$(echo "$RESPONSE" | jq -r '.deployment_id')
        echo "Deployment ID: $DEPLOYMENT_ID"
        echo "deployment_id=$DEPLOYMENT_ID" >> "$GITHUB_OUTPUT"

    - name: Wait for deployment health
      id: health
      shell: bash
      env:
        CONTROL_PLANE_URL: ${{ inputs.control_plane_url }}
        AGENT_ID: ${{ steps.find-agent.outputs.agent_id }}
        DEPLOYMENT_ID: ${{ steps.deploy.outputs.deployment_id }}
        HEALTH_ENDPOINT: ${{ inputs.health_endpoint }}
      run: |
        set -e

        fetch_agent_logs() {
          local agent_id="$1"
          local limit="${2:-50}"
          echo ""
          echo "=== Agent Logs (last $limit entries) ==="
          LOGS=$(curl -sf "$CONTROL_PLANE_URL/api/v1/agents/$agent_id/logs?limit=$limit&min_level=INFO" 2>/dev/null || echo '{"logs":[]}')
          echo "$LOGS" | jq -r '.logs[] | "[\(.container // "unknown")] \(.line)"' 2>/dev/null || echo "No logs available"
          echo "=== End Logs ==="
          echo ""
        }

        echo "Waiting for deployment to become healthy..."
        for i in {1..60}; do
          AGENT_STATUS=$(curl -sf "$CONTROL_PLANE_URL/api/v1/agents/$AGENT_ID" 2>/dev/null || echo '{}')
          AGENT_STATE=$(echo "$AGENT_STATUS" | jq -r '.status // "unknown"')
          HEALTH=$(echo "$AGENT_STATUS" | jq -r '.health_status // "unknown"')
          SERVICE_URL=$(echo "$AGENT_STATUS" | jq -r '.service_url // empty')

          if [ "$AGENT_STATE" = "error" ]; then
            DEPLOY_STATUS=$(curl -sf "$CONTROL_PLANE_URL/api/v1/deployments/$DEPLOYMENT_ID" 2>/dev/null || echo '{}')
            DEPLOY_ERROR=$(echo "$DEPLOY_STATUS" | jq -r '.error // "Unknown error"')
            echo "::error::Deployment failed on agent: $DEPLOY_ERROR"
            echo ""
            echo "Debug info:"
            echo "  Agent ID: $AGENT_ID"
            echo "  Agent status: $AGENT_STATE"
            echo "  Deployment ID: $DEPLOYMENT_ID"
            echo "  Deployment status: $(echo "$DEPLOY_STATUS" | jq -r '.status // "unknown"')"
            fetch_agent_logs "$AGENT_ID" 100
            exit 1
          fi

          DEPLOY_STATUS=$(curl -sf "$CONTROL_PLANE_URL/api/v1/deployments/$DEPLOYMENT_ID" 2>/dev/null || echo '{}')
          DEPLOY_STATE=$(echo "$DEPLOY_STATUS" | jq -r '.status // "unknown"')

          if [ "$DEPLOY_STATE" = "failed" ]; then
            DEPLOY_ERROR=$(echo "$DEPLOY_STATUS" | jq -r '.error // "Unknown error"')
            echo "::error::Deployment failed: $DEPLOY_ERROR"
            echo ""
            echo "Debug info:"
            echo "  Agent ID: $AGENT_ID"
            echo "  Agent status: $AGENT_STATE"
            echo "  Deployment ID: $DEPLOYMENT_ID"
            fetch_agent_logs "$AGENT_ID" 100
            exit 1
          fi

          if [ "$HEALTH" = "healthy" ] && [ -n "$SERVICE_URL" ]; then
            echo "Agent reports healthy at $SERVICE_URL"
            echo "service_url=$SERVICE_URL" >> "$GITHUB_OUTPUT"

            echo "Verifying tunnel connectivity..."
            for j in {1..30}; do
              if curl -sf "${SERVICE_URL}${HEALTH_ENDPOINT}" > /dev/null 2>&1; then
                echo "Tunnel verification passed!"
                BODY=$(curl -s "${SERVICE_URL}${HEALTH_ENDPOINT}" 2>/dev/null || true)
                echo "${BODY:0:500}"
                echo ""
                echo "Deployment complete!"
                exit 0
              fi
              echo "  Waiting for tunnel... ($j/30)"
              sleep 10
            done

            echo "::error::Deployment completed but tunnel not accessible after 5 minutes"
            echo "Agent is healthy but ${SERVICE_URL}${HEALTH_ENDPOINT} is not reachable"
            exit 1
          fi

          echo "  Agent: $AGENT_STATE | Health: $HEALTH | Deploy: $DEPLOY_STATE ($i/60)"
          sleep 5
        done

        echo "::error::Deployment timed out waiting for health"
        echo ""
        echo "Final state:"
        echo "  Agent status: $(echo "$AGENT_STATUS" | jq -r '.status // "unknown"')"
        echo "  Agent health: $HEALTH"
        echo "  Agent service_url: $SERVICE_URL"
        echo "  Deployment status: $DEPLOY_STATE"
        echo "  Deployment error: $(echo "$DEPLOY_STATUS" | jq -r '.error // "none"')"
        fetch_agent_logs "$AGENT_ID" 100
        exit 1
